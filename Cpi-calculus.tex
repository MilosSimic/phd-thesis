%!TEX root =  main.tex
\chapter{A calculus for confidential name passing}\label{chapter:Cpi}



In this chapter, we present the $C_\pi$-calculus, which is a fragment of the $\pi$-calculus~\cite{DBLP:books/daglib/0098267, DBLP:journals/iandc/MilnerPW92a, DBLP:journals/iandc/MilnerPW92b,  pi_calculus}.  
We start by a small introduction on process algebras. %, closely related to our work.

As in the $\pi$-calculus, the building blocks of the $C_\pi$ language are \emph{processes}. 
A process represents an entity that can synchronize with other processes through communication links (channels) that they share.
%The execution of a process is performed by means of channel actions conducted by threads. 
%These actions can be concurrent, and two threads can synchronize their actions. 
Some of the first and well-known process models are a Calculus of Communicating Systems ($CCS$)~\cite{DBLP:books/sp/Milner80} and Communicating Sequential Processes ($CSP$)~\cite{DBLP:books/ph/Hoare85}. 
The latter has influenced the design of Google's \emph{Go} programming language. 
See~\cite{DBLP:journals/tcs/Baeten05} for a more comprehensive overview of the history of process algebras.

The $CCS$-calculus models concurrent systems formally by introducing the notions of parallel composition, synchronization of input and output action on the same name, the private names and the choice. The choice operator is not considered throughout this thesis, and hence we will not mention its interpretation nor its properties.
For instance, a $CCS$ process $\mathit{Alice} \parop \mathit{Bob}$ represents that $\mathit{Alice}$ and $\mathit{Bob}$ are simultaneously active processes. Furthermore, these processes can synchronize via shared name. For instance, in process
\[
\overline{\mathit{chn}}.\mathit{Alice} \parop {\mathit{chn}}.\mathit{Bob}
\] 
process $\overline{\mathit{chn}}.\mathit{Alice}$ can synchronize the output action on name $\mathit{chn}$ with the input action of process ${\mathit{chn}}.\mathit{Bob}$, since both are active in parallel. In that case, the process reduces to $\mathit{Alice} \parop \mathit{Bob}$.

In $CCS$ a name can be specified as private. In process 
\[
(\rest{\mathit{session}}\mathit{Alice}) \parop \mathit{Bob}
\]
name $\mathit{session}$ is known only to $\mathit{Alice}$ and can be used only internally, while $\mathit{Bob}$ cannot acquire the name. What $CCS$ fails to capture directly is name mobility.

The $\pi$-calculus takes as its basis $CCS$, but it extends it in an important way by allowing name mobility.  Namely, processes now can, while synchronizing their actions (via communication channels), transmit names of channels. This model has also influenced the design of several programming languages~\cite{ DBLP:conf/afp/FournetFMS02, DBLP:journals/entcs/MeredithR05,  DBLP:conf/birthday/PierceT00, DBLP:journals/jfp/SewellLWNAHV07,DBLP:conf/wecwis/ThiagarajanSPB02,DBLP:conf/birthday/WelchB04}. For example, in the $\pi$-calculus we may specify 
\[
\send{\mathit{chn}}\role\msg{\mathit{session}}.\mathit{Alice} \parop \receive{\mathit{chn}}\role\msg\NX.\mathit{Bob}
\]
where the left process can send channel name $\mathit{session}$ on channel $\mathit{chn}$, the right process can receive a name on the same channel and replace the placeholder name $\NX$ in $\mathit{Bob}$ with the received name. 
Another important aspect is that a $\pi$ process can share a private communication channel with other processes via synchronization, establishing private connections. 
This is the last ingredient needed to represent the scenario given in the Introduction, as we may now write
\[
(\rest{\mathit{session}}\send{\mathit{chn}}\role\msg{\mathit{session}}.\mathit{Alice}) \parop \receive{\mathit{chn}}\role\mgs{\NX}.\send{\mathit{forward}}\role\msg\NX.\mathit{Bob}'
\]
where the channel $\mathit{session}$ is privately held by the left process. After the synchronization, the above configuration evolves to 
\[
\rest{\mathit{session}}(\mathit{Alice} \parop \send{\mathit{forward}}\role\msg{\mathit{session}}.\mathit{Bob}'')
\]
where private channel $\mathit{session}$ is received in the right process (i.e., $\mathit{Bob}''$ represents the process derived from $\mathit{Bob}'$ by replacing each occurrence of name $\NX$ with name $\mathit{session}$), hence enlarging the scope of the name. Assuming there is a third party active,
\[
\rest{\mathit{session}}(\mathit{Alice} \parop \send{\mathit{forward}}\role\msg{\mathit{session}}.\mathit{Bob}'') \parop \receive{\mathit{forward}}\role\msg\NY.\mathit{Carol}
\]
 the process comprehending $\mathit{Bob}''$ can forward received name $\mathit{session}$ to the third party on channel $\mathit{forward}$ without a need to notify $\mathit{Alice}$, hence potentially compromising the privacy of $\mathit{Alice}$ (cf. Section~\ref{sec:intro_sharing_control}). 

%Both features add considerably to the expressive power of the $\pi$-calculus. 

The subject of this section, the $C_\pi$-calculus, allows reasoning on confidentiality in a fragment of the $\pi$-calculus. 
By restricting forwarding in a way that channel name once received by a process cannot be later sent by the same process, we gain a suitable abstraction level to reason on, e.g., groups~\cite{cardelli05} and name hiding~\cite{Giunti}, directly in the $C_\pi$ without additional language constructs. Since we are dealing only with a fragment of the $\pi$-calculus rather than with its extension, our model can reuse all the theory already developed for the $\pi$.

Extensive theoretical research conducted in the past is directly connected to the $\pi$-calculus in many ways. 
Many of these works extend the $\pi$-calculus syntax by variety of constructs so as to gain a suitable abstraction level to reason about, e.g.,  
polyadic communications~\cite{DBLP:journals/njc/CarboneM03, DBLP:conf/concur/Milner92}, 
higher-order communication~\cite{DBLP:conf/csl/Milner93}, 
distributed systems~\cite{DBLP:books/daglib/0018113}, and many others, including 
security and privacy~\cite{appliedpi,spi,cardelli05,pigroups,Giunti,hennessy05}.
In contrast, some of the research exploits restricting the syntax of the $\pi$-calculus to reason on asynchronous communications~\cite{boudol:inria-00076939, DBLP:conf/ecoop/HondaT91}, internal mobility~\cite{DBLP:journals/tcs/Sangiorgi96a}, and locality~\cite{merro04}.



\paragraph{Overview of the chapter.}
The syntax of the process model is presented in Section~\ref{sec:Cpi-syntax}. 
The action semantics is presented in Section~\ref{sec:Cpi-semantics}, followed by an investigation of some basic properties together with the definition of the non-forwarding property in Section~\ref{sec:Cpi_properties_of_lts}. The reduction semantics is briefly introduced in Section~\ref{sec:Cpi-reduction-semantics}. 
Section~\ref{sec:Cpi-bisimilarity} presents a behavioral equivalence (strong bisimilarity) and a property called closed domains for channels, capturing that closing the scope of a channel can be represented directly in $C_\pi$. 
Section~\ref{sec:strong_barbed_equivalence} briefly presents another behavioral equivalence, the strong barbed equivalence relation, and Section~\ref{sec:the_non-forwarding_of_pi_processes} gives a method for identifying non-forwarding $\pi$ processes.
In Section~\ref{sec:examples} we present some interesting scenarios modeled in $C_\pi$, such as  authentication schemes (Section~\ref{sec:authentication}), closing the domain for channels (Section~\ref{sec:groups}), and open-ended groups (Section~\ref{sec:open-ended-groups}). Section~\ref{sec:encoding} presents an encoding from the $\pi$-calculus into the $C_\pi$-calculus and the operational correspondence result that validates the encoding and informs on the expressive power of $C_\pi$. 



%
\begin{table}[t]
\[
\displaystyle
\begin{array}[t]{rcl@{\qquad\qquad\qquad}r}
 \pi & ::= & 								 &   \emph{Prefixes}\\
     &        & \send\NA\role\msg\NK    	 &   \text{output}\\
     & \parop & \receive\NA\role\msg{x} 	 &   \text{input}\\
     & \parop & \match\NA\role\msg\NB\pi     &   \text{matching}\\
     &        &								 &   \\
  \PP & ::= & 								 &	 \emph{Process terms}\\
     &        & \inact 						 &   \text{termination}\\
     & \parop & \pi.\PP  					 &   \text{prefix}\\
     & \parop & \PP\parop\PP 				 &   \text{parallel composition}\\
     & \parop & \rest\NK \PP  				 &   \text{name restriction}\\
     & \parop & \rep\PP 					 &   \text{replication}\\
\end{array}
\]
\caption{\label{tab:Cpi_syntax} Syntax of $C_\pi$}
\end{table}
%




\section{Syntax}\label{sec:Cpi-syntax} 

In this section, we introduce the language of the $C_\pi$-calculus. 
As we have noted, the building blocks of our language are processes, 
and processes may communicate using names. 
The names themselves are an abstraction for communication links. Communication links are modeled as named communication channels that can connect two or more processes. 

In $C_\pi$, we distinguish \emph{variable} and \emph{channel} names by introducing two disjoint sets for each kind. 
We use $\Chn$ to denote the set of channel names, ranged over by $\NK, \NL, \NM, \ldots$, and $\Var$ to 
denote the set of variable names, ranged over by $\NX, \NY, \NZ, \ldots$ 
The union of the two sets is denoted by $\N$, and we let $\NA, \NB, \NC, \ldots$ range over $\N$. 
The use of each of the sets is explained below when language constructs are introduced.


The syntax of the language is given in Table~\ref{tab:Cpi_syntax}. Notice that we do not consider the sum operator~\cite{pi_calculus} since our goal is to study confidentiality in a minimal setting, but we believe the sum can be added following expected lines.
The first part of the table introduces the prefixes, used in the definition of three types of processes: 
%
\begin{itemize}
\item The output prefix $\send\NA\role\msg\NK.\PP$ describes an action in which the object, channel name $\NK$, is sent on the subject, name $\NA$,  after which the process evolves to $\PP$. 
Notice that only a channel name, i.e., a name from set $\Chn$, can be the object of an output action. 
This is the only difference with respect to the $\pi$-calculus, where the name of a variable can also appear as the object of an output action. 
The subject of an output action can be either a channel or variable name, like in the $\pi$-calculus. 
Hence, received names can be used to communicate but cannot be communicated. For example, process $\send\NB\role\msg\NK.\inact$ can send $\NK$ on $\NB$ and evolve to $\inact$.
%
\item The input prefix $\receive\NA\role\msg\NX.\PP$ describes an action in which a name is received on the subject name $\NA$. The received name is substituted in the continuation process $\PP$ for a variable name $\NX$, and the original process evolves to the term resulting from this substitution. Here, $\NX$, also called a placeholder, is bound in process $\PP$ (see Definition~\ref{def:Cpi_bound_names}). 
For example, process $\receive\NA\role\msg\NX.\send\NX\role\msg\NK.\inact$ can receive a name on $\NA$ and substitute $\NX$ by it in the continuation. 
Assuming the received name is $\NB$, the above process evolves to $\send\NB\role\msg\NK.\inact$. 
Notice that the object of an input can only be a variable name, i.e., name from set $\Var$. 
Hence, process as $\receive\NA\role\msg\NX.\send\NK\role\msg\NX.\inact$ excluded by the $C_\pi$ syntax is a $\pi$ process.
\item The match prefix $\match\NA\role\msg\NB\pi.\PP$ activates the action prescribed by prefix $\pi.\PP$ only if $\NA=\NB$ and it blocks the action otherwise. For example, process 
$\receive\NA\role\msg\NX.\match\NX\role\msg\NB\send\NX\role\msg\NK.\inact$ 
receives a name on $\NA$, then either: it sends $\NK$ on $\NB$ if the name received is $\NB$; else if the received name is not $\NB$ it performs no further actions.
\end{itemize}

We comment the rest of the process constructs:
\begin{itemize}
\item The termination $\inact$ denotes the process that exhibits no actions. 
Notice that we have used it in the examples above to signal when a thread has performed all its 
actions.
%
\item The parallel composition $\PP \parop \PP$ denotes that two processes are simultaneously active, and possibly can synchronize their actions. 
For example, in $\send\NA\role\msg\NK.\inact \parop \receive\NA\role\msg\NX.\send\NX\role\msg\NL.\inact$ 
the left thread can synchronize the output action with the input action of the right thread, and   
%in which case the above configuration evolves to $\inact \parop \send\NK\role\msg\NL.\inact$. 
%Notice also that the synchronization does not have to take place and that above configuration 
can also exhibit any of the individual actions of the two threads.
%
\item The name restriction $\rest\NK\PP$ denotes the creation of a new (channel) name $\NK$, 
known only to process $\PP$. 
Channel $\NK$ can be used as a private medium for communications of the components of process $\PP$. 
For example, process $\rest\NK(\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\inact)$ 
can use channel $\NK$ for synchronization of the two threads but cannot interact with other processes along channel $\NK$.
On the other hand, the restricted channel can be shared with other processes if it is communicated in a message. 
The explanation of sharing restricted names and its interplay with confidentiality in $C_\pi$ can be found in  Section~\ref{sec:Cpi-semantics}, Section~\ref{sec:Cpi-bisimilarity} and Section~\ref{sec:examples}.
%
\item The replication $\rep\PP$ denotes a process with potentially infinite behavior. 
Informally, $\rep\PP$ can be seen as an infinite parallel composition of the copies of process 
$\PP$, i.e., $\PP\parop\PP\parop\ldots$. 
For example, process $\rep\send\NA\role\msg\NK.\PQ$ can send $\NK$ on $\NA$ and activate 
the original process in parallel. %, evolving to  $\PQ \parop \rep\send\NA\role\msg\NK.\PQ$.
\end{itemize}


We name the operators' precedence from highest to lowest: prefixes, name restriction, replication, and parallel 
composition. 
For example, the above process 
$\send\NA\role\msg\NK.\inact \parop \receive\NA\role\msg\NX.\send\NX\role\msg\NL.\inact$ stands for 
$(\send\NA\role\msg\NK.\inact) \parop (\receive\NA\role\msg\NX.(\send\NX\role\msg\NL.\inact))$, 
%process $\rep\send\NA\role\msg\NK.\PP$ stands for $\rep(\send\NA\role\msg\NK.\PP)$, 
and $\rest\NK\PP \parop \PQ$ stands for $(\rest\NK\PP) \parop \PQ$.


We denote with $\n\PP$ the set of all names (channels and variables from $\N$) appearing in the process $\PP$. 
Some of these names are said to be \emph{free}, while the rest are called \emph{bound}. 

\begin{definition}[Free and bound names]\label{def:Cpi_bound_names}
For any $C_\pi$ process the set of free names $\fn\PP$ and the set of bound names $\bn\PP$ are defined  as follows.
\[
\begin{array}{rcl}
\fn{\inact} & = & \emptyset\\
\fn{\send\NA\role\msg\NK.\PP} & = & \{\NA, \NK\} \cup \fn\PP\\
\fn{\receive\NA\role\msg\NX.\PP} & = & \{\NA\} \cup (\fn\PP\setminus\{\NX\})\\
\fn{\match\NA\role\msg\NB\pi.\PP} & = &  \{\NA, \NB\} \cup \fn{\pi.\PP}\\
\fn{\PP \parop\PQ} & = & \fn\PP \cup \fn\PQ\\
\fn{\rest\NK\PP} & = & \fn\PP\setminus \{\NK\}\\
\fn{\rep\PP} & = & \fn\PP
\end{array}
\qquad
\begin{array}{rcl}
\bn{\inact} & = & \emptyset\\
\bn{\send\NA\role\msg\NK.\PP} & = & \bn\PP\\
\bn{\receive\NA\role\msg\NX.\PP} & = & \{\NX\} \cup \bn\PP\\
\bn{\match\NA\role\msg\NB\pi.\PP} & = &  \bn{\pi.\PP}\\
\bn{\PP \parop\PQ} & = & \bn\PP \cup \bn\PQ\\
\bn{\rest\NK\PP} & = & \{\NK\} \cup \bn\PP\\
\bn{\rep\PP} & = & \bn\PP
\end{array}
\]
\end{definition}

Notice that in $\rest\NK \PP$ and $\receive\NA\role\msg\NX.\PP$ the channel 
$\NK$ and variable $\NX$ are bound and that these are the only operators that bind names. 
In these two cases, we say that $\NK$ and $\NX$ are binding 
with \emph{scope} $\PP$. 
The scope of a bound name determines the process which is the only one that knows the name.
Notice that $\fn\PP=\n\PP\setminus\bn\PP$. 
For free names, the scope is not predefined since free names may be known by other processes.
We also identify a set of free channels appearing as objects of output prefixes in a process, so as to be able to talk about names a process can send.
%
\begin{definition}[Free output object names]\label{def:Cpi_fo}
For any $C_\pi$ process $\PP$, the set of free output object names $\fo\PP$ is defined as follows.
\[
\begin{array}{rcl}
\fo{\inact} & = & \emptyset\\
\fo{\send\NA\role\msg\NK.\PP} & = & \{\NK\} \cup \fo\PP\\
\fo{\receive\NA\role\msg\NX.\PP} & = &  \fo\PP\\
\fo{\match\NA\role\msg\NB\pi.\PP} & = &  \fo{\pi.\PP}\\
\fo{\PP \parop\PQ} & = & \fo\PP \cup \fo\PQ\\
\fo{\rest\NK\PP} & = & \fo\PP\setminus\{\NK\}\\
\fo{\rep\PP} & = & \fo\PP
\end{array}
\]
\end{definition}


% We have informally  the substitution of names in the example where  
%$\send\NA\role\msg\NK.\inact \parop \receive\NA\role\msg\NX.\send\NX\role\msg\NL.\inact$ 
%evolves to 
%$\inact \parop \send\NK\role\msg\NL.\inact$, 
%where $\NX$ in the continuation of the right thread has been substituted for the received name $\NK$. 
To precisely define replacements of names in processes (such as the ones described in the receive actions) we give a precise definition of the substitution.  Before that, we introduce a convention that bound names must not be mentioned by substitutions (we will come back to this point).

\begin{definition}[Substitution]\label{def:Cpi_substitutions}
A substitution is a mapping from $\N$ to $\N$ that is not the identity only on a finite subset of $\N$, and that maps $\Chn$ only to $\Chn$. We define the support of $\sigma$ to be finite set $\{\NA\;|\; \sigma{\NA}\not=\NA \}$, and the co-support of $\sigma$ to be finite set $\{\sigma(\NA) \;|\; \sigma{\NA}\not=\NA \}$. We write $\n\sigma$ for the union of the support and the co-support of $\sigma$.
If substitution $\sigma$ is applied to process $\PP$, then the resulting process $\PP\sigma$ is defined  as follows.
\[
\begin{array}{rclr}
\inact\sigma & = & \inact\\
(\send\NA\role\msg\NK.\PP)\sigma & = & \send{\sigma(\NA)}\role\msg{\sigma(\NK)}.\PP\sigma \\ %, &\text{ where } \sigma(\NK)\in\Chn \\
(\receive\NA\role\msg\NX.\PP)\sigma & = & \receive{\sigma(\NA)}\role\msg{\NX}.\PP\sigma\\ %, & \text{ where } \NX\notin\n\sigma \\
(\match\NA\role\msg\NB\pi.\PP)\sigma & = &  (\match{\sigma(\NA)}\role\msg{\sigma(\NB)}(\pi.\PP)\sigma\\
(\PP \parop\PQ)\sigma & = & \PP\sigma \parop \PQ\sigma\\
(\rest\NK\PP)\sigma & = & \rest{\NK} \PP\sigma\\ %,   & \text{ where } \NK\notin\n\sigma\\
(\rep\PP)\sigma & = & \rep\PP\sigma
\end{array}
\]
If the support of $\sigma$ is $\{\NA_1, \ldots, \NA_n\}$, and $\sigma(\NA_i)=\NB_i$, for $i=1,\ldots,n$, then instead of $\PP\sigma$ we may also write $\PP\subst{\NB_1, \ldots, \NB_n}{\NA_1, \ldots, \NA_n}$.
\end{definition}
%
For example, we have  
$(\send\NX\role\msg\NL.\inact)\subst{\NK}{\NX}=\send\NK\role\msg\NL.\inact$. 
Notice also that substitution applied on a process does not affect the bound names of the process. 
Only free names can be substituted and the convention preceding Definition~\ref{def:Cpi_substitutions} ensures that substitution does not map free names into bound names. %, as ensured by the side-conditions in the definition. 
This is required to avoid name clashes, the notion explained next.

So far, our syntax allows us to define a process in which a name may be used in distinct binding occurrences, and also to appear free elsewhere.
%which interfere with our interpretation that a bound name cannot be known outside of its scope. 
For example, we can write 
$\rest\NK\send\NA\role\msg\NK.\inact \parop \rest\NK\receive\NA\role\msg\NX.\send\NX\role\msg\NK.\inact$, 
where, the two restricted names are identified with the same $\NK$. After synchronization of the two branches, name $\NK$ from the left branch can clash with the $\NK$ in the right branch. 
In order to simplify the handling of bound names, which are to be considered distinct regardless of their identifier, we identify processes up to $\alpha$-conversion defined next.
%To avoid this type of bound name clashes we identify  processes up to $\alpha$-conversion.
%
\begin{definition}[$\alpha$-conversion]\label{def:alpha-conversion}
Processes $\PP$ and $\PQ$ are $\alpha$-convertible if we may obtain $\PQ$ from $\PP$ by a finite number of replacements of subterms $\rest\NK\PP_1$ and $\receive\NA\role\msg\NX.\PP_2$ in $\PP$ by $\rest\NL\PP_1\subst{\NL}{\NK}$ and $\receive\NA\role\msg\NY.\PP_2\subst{\NY}{\NX}$, where $\NL\notin\n{\PP_1}$ and $\NY\notin\n{\PP_2}$.
If $\PP$ and $\PQ$ are $\alpha$-convertible we write $\PP\equiv_\alpha\PQ$.
\end{definition}
%
Notice that since we identify $\alpha$-convertible processes, $\PP\equiv_\alpha \PQ$ implies $\PP=\PQ$.
We may then say that process
$\rest\NK\send\NA\role\msg\NK.\inact \parop \rest\NK\receive\NA\role\msg\NX.\send\NX\role\msg\NK.\inact$ is 
equal to 
\[
\rest\NK\send\NA\role\msg\NK.\inact \parop \rest\NM\receive\NA\role\msg\NX.\send\NX\role\msg\NM.\inact
\] 
which allows avoiding the name clash when reasoning on the synchronization.
%where $\NK$ in the right thread is renamed to $\NM$, and after the synchronization, the two bound names do not clash.

To avoid name clashes, in general, %including cases where a bound name can clash with a free name, as in process  $\rest\NK\send\NA\role\msg\NK.\inact \parop \receive\NA\role\msg\NX.\send\NX\role\msg\NK.\inact$, where in the left thread $\NK$ is bound, while in the right thread the same name appears as free,
we use a sort of Barendregt convention as adopted in the $\pi$-calculus in~\cite{pi_calculus} Convention~$1.1.7$,
which states that all free names and names of the substitutions are distinct from all bound names in any processes and substitutions under consideration. 
%Notice that this exactly matches Convention~$1.1.7.$ in~\cite{pi_calculus}. 
Furthermore, to avoid explicitly working with $\alpha$-conversion, we also assume that all bound names among themselves in any process under consideration are different. 

We remark that this treatment of bound and free names is appealing in theoretical works on the $\pi$-calculus such as ours, but when a formalization of the $\pi$-calculus in some theorem proving systems (e.g., Coq~\cite{DBLP:series/txtcs/BertotC04}, Isabelle/HOL~\cite{DBLP:books/sp/NipkowPW02}) is conducted, a more precise way of handling free and bound names is needed, like adopting de Bruijn notation of names~\cite{DEBRUIJN1972381} to the $\pi$-calculus~\cite{DBLP:conf/tphol/Gay01, DBLP:conf/tphol/Hirschkoff97,  DBLP:journals/mscs/PereraC18}.













\section{Action semantics}\label{sec:Cpi-semantics} 


In the previous section, we informally presented some examples where processes perform inputs, outputs and synchronize their actions. 
We formalize these notions in this section where we define the action semantics of our model in terms of a labeled transition system, that in turn matches the one of~\cite{pi_calculus} for the sum-free $\pi$-calculus.
Intuitively, each process evolution involves three parts: the starting process, the action performed and the resulting process. 
This kind of operational semantics allows us to characterize the behavior of a process relying on the behavior of its subparts, including their interactions.
%by splitting it into the parts and observing their interactions.
An action of a process describes what the environment can observe when interacting with the process. We now define the actions.
%
\begin{definition}[Actions]\label{def:Cpi_actions}
The observable action $\alpha$ is defined as   
\[
\alpha ::= \quad \send\NK\role\msg\NL \quad \parop \quad \receive\NK\role\msg\NL \quad \parop \quad \rest\NL\send\NK\role\msg\NL \quad \parop \quad \tau
\]
and we denote with ${\cal A}$ the set of all actions.
\end{definition}
%
We may recognize that the first two actions correspond to the process prefixes. 
Prefixes $\send\NK\role\msg\NL.\PP$ and $\receive\NK\role\msg\NX.\PP$ 
describe the potential of a process to perform an action and observable actions 
$\send\NK\role\msg\NL$ and $\receive\NK\role\msg\NL$ describe the action itself:
the first sending and the second receiving the channel $\NL$ on the channel $\NK$. 
Notice that in our (early) semantics, the input action already identifies the received channel ($\NL$), and does not mention the input prefix variable ($\NX$). 
In action $\rest\NL\send\NK\role\msg\NL$ the sent channel $\NL$ is bound, denoting that process performing the action sends a fresh channel (here $\NL$). 
This allows for scope extrusion, explained later.
A process performing invisible action $\tau$ evolves internally, hence without interacting with the environment.
%by not exposing its actions to the environment. 
%Notice that, as in the $\pi$-calculus, names bound in input (variables) cannot appear in 
%labels of observable actions. 
To retain the same notation as for processes, we denote by 
$\fn\alpha$, $\bn\alpha$ and $\n\alpha$, the sets of free, bound and all names of action $\alpha$, respectively. 
As we noted above, these sets contain only channels, and not variables.
%
\begin{definition}[Free and bound names of actions]\label{def:free_and_bound_name_of_actions}
For observable action $\alpha$ we define a set of free and bound names as follows.
\[
\begin{array}{rcl}
\fn{\send\NK\role\msg\NL} & = & \{\NK, \NL\}\\
\fn{\rest\NL\send\NK\role\msg\NL} & = & \{ \NK\}\\
\fn{\receive\NK\role\msg\NL} & = & \{\NK, \NL\} \\
\fn\tau & = & \emptyset
\end{array}
\qquad\quad
\begin{array}{rcl}
\bn{\send\NK\role\msg\NL} & = & \emptyset\\
\bn{\rest\NL\send\NK\role\msg\NL} & = & \{ \NL\}\\
\bn{\receive\NK\role\msg\NL} & = & \emptyset \\
\bn\tau & = & \emptyset\\
\end{array}
\]
\end{definition}
%

As for the processes, we extend here our convention that all free names are different from the bound names, and that all bound names are pairwise distinct, 
not only in all processes and substitutions but also including all actions under consideration. The only exception of this convention is when the scope extrusion is performed, as explained later. This matches Convention~$1.4.10$ in~\cite{pi_calculus}.
%Also, when convenient we will assume that all bound names are pairwise distinct. This restriction can always be satisfied by renaming bound names of a process (since we are identifying $\alpha$-convertible processes).


\begin{table}[t]
\[
\begin{array}[t]{@{}c@{}}
\inferrule[(out)]{}
{\send\NK\role\msg\NL.\PP\lts{\send\NK\role\msg\NL}\PP}
\qquad
\inferrule[(in)]{}
{\receive\NK\role\msg\varx.\PP\lts{\receive\NK\role\msg\NL}\PP\subst\NL\varx}
\qquad
\inferrule[(match)]
{\pi.\PP\lts{\alpha}\PP'}
{\match\NA\role\msg\NA\pi.\PP\lts{\alpha}\PP'}
\vspace{2ex}\\
\inferrule[(res)]
{\PP\lts{\alpha}\PP' \quad k\notin\n\alpha}
{\rest\NK \PP \lts{\alpha}\rest\NK\PP'}
\qquad
\inferrule[(open)]
{\PP\lts{\send\NK\role\msg\NL}\PQ \quad k\not= l}
{\rest\NL\PP\lts{\rest\NL\send\NK\role\msg\NL}\PQ }
\vspace{2ex}\\
\inferrule[(par-l)]
{\PP\lts{\alpha}\PQ \quad \bn\alpha\cap\fn\PR=\emptyset}
{\PP\parop\PR\lts{\alpha}\PQ\parop\PR}
\qquad
\inferrule[(comm-l)]
{\PP\lts{\send\NK\role\msg\NL}\PP' \quad \PQ\lts{\receive\NK\role\msg\NL}\PQ'}
{\PP\parop\PQ\lts{\tau}\PP'\parop\PQ'}
\vspace{2ex}\\
\inferrule[(close-l)]
{\PP\lts{\rest\NL\send\NK\role\msg\NL}\PP' \quad \PQ\lts{\receive\NK\role\msg\NL}\PQ' \quad \NL\notin \fn{\PQ}}
{\PP\parop\PQ\lts{\tau}(\nu \NL)(\PP'\parop\PQ')}
\qquad
\inferrule[(rep-act)]
{\PP\lts{\alpha}\PP'}
{\rep\PP\lts{\alpha}\PP'\parop \rep\PP}
\vspace{2ex}\\
\inferrule[(rep-comm)]
{\PP\lts{\send\NK\role\msg\NL}\PP' \quad \PP\lts{\receive\NK\role\msg\NL} \PP''}
{\rep\PP\lts{\tau} (\PP' \parop \PP'') \parop \rep\PP}
\qquad
\inferrule[(rep-close)]
{\PP\lts{\rest\NL\send\NK\role\msg\NL}\PP' \quad \PP\lts{\receive\NK\role\msg\NL} \PP'' \quad \NL\notin\fn\PP}
{\rep\PP\lts{\tau} \rest\NL(\PP' \parop \PP'')\parop  \rep\PP}
\end{array}
\]
\caption{\label{tab:Cpi_Transition}LTS Rules.}
\end{table}


The labeled transition relation is the least relation in ${\cal P}\times{\cal A}\times{\cal P}$, 
where ${\cal P}$ is the set of all processes, that satisfies the rules given in Table~\ref{tab:Cpi_Transition}. 
We describe the rules on salient points.
%
\begin{itemize}
%
%
\item Rules \rulename{(out)}, \rulename{(in)} and \rulename{(match)} directly correspond to the explanations 
of the corresponding syntactic constructs. 
For example, considering process $\receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact$ receives channel $\NL$,  by rule \rulename{(in)} we derive 
\[
\receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact
\lts{\receive\NK\role\msg\NL}
\match\NL\role\msg\NL\send\NL\role\msg\NM.\inact
\]
%
where the received channel $\NL$ substitutes the variable $\NX$.
Since by rule \rulename{(out)} we derive
\[
\send\NL\role\msg\NM.\inact 
\lts{\send\NL\role\msg\NM}
\inact
\]
%
and since the matched names preceding the output coincide, by \rulename{(match)} we have that  
%
\[
\match\NL\role\msg\NL\send\NL\role\msg\NM.\inact
\lts{\send\NL\role\msg\NM}
\inact
\]
%
If the received channel in process $\receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact$ 
is not $\NL$, but, say $\NN$, again by \rulename{(in)} we derive
%
\[
\receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact
\lts{\receive\NK\role\msg\NN}
\match\NN\role\msg\NL\send\NN\role\msg\NM.\inact
\]
%
only now the output action of the final process is blocked due to the mismatch in the prefix, and hence the process cannot perform further actions. 
This is the consequence of the fact that the only rule in Table~\ref{tab:Cpi_Transition} that %here could be applied after \rulename{(out)} is the only rule 
deals with the match operator, i.e., \rulename{(match)}, cannot be applied since $\NN$ and $\NL$ are distinct. 
Notice also that in the above example the transitions are justified by rules in Table~\ref{tab:Cpi_Transition} in a unique way, 
in a sense that only rules \rulename{(in)}, \rulename{(out)} and \rulename{(match)}, 
respectively, can be applied.
%
%
\item Rule \rulename{(res)} lifts the action of the process scoped with channel restriction and ensures that the action does not mention the channel specified in the restriction. 
The effect of the side condition is that the restricted channel is never mentioned in the action visible to the process's environment, hence keeping the channel private. The only exception is when a channel is sent in a message (cf. rule \rulename{(open)}). 
For example, for process $\send\NK\role\msg\NL.\inact$, by \rulename{(out)}, we can derive 
\[\send\NK\role\msg\NL.\inact
\lts{\send\NK\role\msg\NL}
\inact
\]
but restricting channel $\NK$ in the above process we end up with process $\rest\NK\send\NK\role\msg\NL.\inact$  which only action (output) is blocked due to the side condition of \rulename{(res)}. 
Also, process $\rest\NL\send\NK\role\msg\NL.\inact$ is blocked by this rule, however, it can proceed by applying the rule explained next.
%
%
\item Rule \rulename{(open)} allows for sending a restricted channel by opening its scope, 
which, combined with rule \rulename{(close-l)} (explained later), enables the communication of restricted names, where their scope is enlarged as a consequence (scope extrusion). 
Going back to the last example, applying rule \rulename{(open)} after \rulename{(out)} we derive
\[
\rest\NL\send\NK\role\msg\NL.\inact
\lts{\rest\NL\send\NK\role\msg\NL} \inact
\]
where the label of the action carries the information that the channel sent is fresh. 
Notice that the side condition of the rule ensures that the subject of the action is not 
the restricted one, therefore, processes $\rest\NK\send\NK\role\msg\NL.\inact$ and $\rest\NK\send\NK\role\msg\NK.\inact$, cannot evolve, as no rule of Table~\ref{tab:Cpi_Transition} can be applied.
%
%
\item In rule \rulename{(par-l)} the action of the left branch is lifted at the level of the parallel composition while avoiding the case when the bound channel of the action is specified as free in the right branch. 
The symmetric rule \rulename{(par-r)}, where the action originates from the right branch is omitted from the table.
For example, by \rulename{(out)} and \rulename{(par-l)} we may derive 
\[
\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact
\lts{\send\NK\role\msg\NL} 
\inact \parop \receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact
\]
where the process carry out the action of the left branch and the right branch does not exhibit any action. 
Rules \rulename{(par-l)} and \rulename{(par-r)} combined allow to interleave the behavior of both branches, capturing the fact that both branches are active.
Moreover, the left branch can synchronize the action with the right branch: this is explained by the next rule.
%
%
\item Rule \rulename{(comm-l)} describes the synchronization of the two dual external actions, output and input. 
After the synchronization the observable action of the overall process is an internal step, i.e., $\tau$, 
denoting that the process at this point is not interacting with the environment.
In the example above, applying \rulename{(out)} and \rulename{(in)} we derive 
\[
\send\NK\role\msg\NL.\inact
\lts{\send\NK\role\msg\NL}
\inact 
\;\;\text{ and }\;\;
\receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact
\lts{\receive\NK\role\msg\NL}
\match\NL\role\msg\NL\send\NL\role\msg\NM.\inact
\]
then, by \rulename{(comm-l)} we have that
\[
\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact
\lts{\tau} 
\inact \parop \match\NL\role\msg\NL\send\NL\role\msg\NM.\inact
\]
We also omit the symmetric cases of the rules \rulename{(comm-l)} and \rulename{(close-l)}.
%
%
\item Rule \rulename{(close-l)} handles the case when the name sent by the left branch is bound. 
The right branch again performs the input action, and after 
the synchronization, the scope of the sent channel, previously opened in rule \rulename{(open)}, is now closed.
As an example, consider process $\rest\NL\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact$. 
By rules \rulename{(out)}, \rulename{(open)} and \rulename{(in)} we get
\[
\rest\NL\send\NK\role\msg\NL.\inact
\lts{\rest\NL\send\NK\role\msg\NL} \inact
\qquad\qquad
\receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact
\lts{\receive\NK\role\msg\NL}
\send\NL\role\msg\NM.\inact
\]
and by \rulename{(close-l)}
\[
\rest\NL\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact
\lts{\tau} 
\rest\NL(\inact \parop \send\NL\role\msg\NM.\inact)
\]
The side condition ensures that the received channel is not specified as free in the right branch, thus avoiding unintended name capturing. 
%Notice that, by our convention on bound and free names, such condition (and the side condition of rules \rulename{(par-l)} and \rulename{(rep-close)}) may be interpreted as redundant, since there we assume that a free name cannot be identified with a bound one. 
%Hence, term 
%$\rest\NL\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact$
%would not be considered as part of our syntax since name $\NL$ is  bound in the left branch, but free in the right branch. In such case, we need to $\alpha$-convert the term, by renaming channel $\NK$ in the left branch, e.g., a representative process would be
%$\rest\NN\send\NK\role\msg\NN.\inact \parop \receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact$, where we make sure that channel $\NN$ is not mentioned in any process that is under consideration.
%Notice, however, that name $\NL$ is free in labeled action $\receive\NK\role\msg\NL$ and in the process $\send\NL\role\msg\NM.\inact$, while being bound in action $\rest\NL\send\NK\role\msg\NL$ and process $\rest\NL\send\NK\role\msg\NL.\inact$. As we noted, this case is excepted from our convention, since otherwise, scope extrusion would not be possible.
%
%
\item Rules \rulename{(rep-act)} allows for a replicated process to perform an action while activating a copy of the original process in parallel.
For example, since by \rulename{(in)} we can derive 
\[
\receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact
\lts{\receive\NK\role\msg\NL}
\match\NL\role\msg\NL\send\NL\role\msg\NM.\inact
\]
Then, by \rulename{(rep-act)} we conclude
\[
\rep\receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact
\lts{\receive\NK\role\msg\NL}
\match\NL\role\msg\NL\send\NL\role\msg\NM.\inact \parop \rep\receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact
\]
Thus, we may say that process $\rep\receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact$ 
is repeatably available to receive a channel and afterwards send $\NM$ only if the received  channel is $\NL$.
%
\item Rules \rulename{(rep-comm)} and \rulename{(rep-close)} allow for two copies of the same replicated process to synchronize their actions, where in the latter rule the communicated channel is fresh. 
As an example consider process 
\[
\PP=\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact\]
By rules \rulename{(out)} and \rulename{(par-l)} we can derive 
\[
\PP
\lts{\send\NK\role\msg\NL}
\inact \parop \receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact
\]
and by rules \rulename{(in)} and \rulename{(par-r)} also
\[
\PP
\lts{\receive\NK\role\msg\NL}
\send\NK\role\msg\NL.\inact \parop \match\NL\role\msg\NL\send\NL\role\msg\NM.\inact
\]
Then, by rule \rulename{(rep-comm)} we have 
\[
\rep\PP
\lts{\tau}
(\inact \parop \receive\NK\role\msg\NX.\match\NX\role\msg\NL\send\NX\role\msg\NM.\inact) \parop (\send\NK\role\msg\NL.\inact \parop \match\NL\role\msg\NL\send\NL\role\msg\NM.\inact) \parop \rep\PP
\]
%
%
%

Let us now consider process
\[
\PQ=\rest\NL\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact
\]
By rules \rulename{(out)}, \rulename{(open)} and \rulename{(par-l)} 
\[
\PQ
\lts{\rest{\NL'}\send\NK\role\msg{\NL'}}
\inact \parop \receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact
\]
where we $\alpha$-converted $\PQ$ by renaming $\NL$ with a fresh channel $\NL'$, to represent that the restricted name of this copy of $\PQ$ is unique. 
Let us now take another copy of $\PQ$ and let us by \rulename{(in)} derive
$\receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact\lts{\receive\NK\role\msg{\NL'}}\send{\NL'}\role\msg\NM.\inact$, where the received channel matches the one sent by the first copy of $\PQ$. 
Since the restricted channel of the second copy of $\PQ$ is also fresh, and hence, to be distinguished from $\NL$ (and also $\NL'$), we $\alpha$-convert $\PQ$ again by renaming $\NL$ to some fresh channel $\NL''$ and then we apply \rulename{(par-r)}
\[
\PQ
\lts{\receive\NK\role\msg{\NL'}}
\rest{\NL''}\send\NK\role\msg{\NL''}.\inact \parop \send{\NL'}\role\msg\NM.\inact
\]
Then, by \rulename{(rep-close)} we get
\[
\rep\PQ 
\lts{\tau}
\rest{\NL'}(
\inact \parop \receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact 
\parop 
\rest{\NL''}\send\NK\role\msg{\NL''}.\inact \parop \send{\NL'}\role\msg\NM.\inact
)
\parop \rep\PQ
\]
Notice that introducing fresh channels by $\alpha$-converting each copy of process $\PQ$ resulted 
that in the last derived process %$\rest{\NL''}\send\NK\role\msg{\NL''}.\inact \parop \send{\NL'}\role\msg\NM.\inact$
 each bound channel is distinct, thus avoiding name clashes.
\end{itemize}
%
The derivation in the last example was possible thanks to Definition~\ref{def:alpha-conversion} since all $\alpha$-converted processes are implicitly identified. %Hence, in the above we have $\PQ=\PQ\subst{\NL'}{\NL}=\PQ\subst{\NL''}{\NL}$.
This kind of derivations as in the last example can be formalized by introducing the explicit rule
\[
\inferrule[]
{\PP\lts{\alpha}\PQ \qquad \PP\equiv_\alpha\PR}
{\PR\lts{\alpha}\PQ}
\] 
which follows directly by considering processes equal up to $\alpha$-conversion.



















\subsection{Properties of the labeled transition system}\label{sec:Cpi_properties_of_lts}
This section presents some basic properties of the labeled transition system (LTS). 
Let us recall that the LTS introduced in Section~\ref{sec:Cpi-semantics}, perfectly matches the one given in~\cite{pi_calculus} (for the sum-free $\pi$-calculus). Hence, since $C_\pi$-calculus is a fragment of the $\pi$-calculus, all the results given in~\cite{pi_calculus} hold also for the $C_\pi$. %concerning the properties of the LTS, but also many other results, as we will see throughout this chapter. Therefore, 
We present here only the results specific to our model.

The distinguishing feature of the $C_\pi$-calculus syntax, that variables do not appear as objects of output prefixes, reflects in the evolutions of processes. Namely, the set of free objects of output prefixes in the process is possibly augmented only by opening the scope of a channel. 
Another specific property is that the set of free objects of output prefixes in the process is invariant to input actions. These results are stated in the next lemma. 

\begin{lemma}[Free output objects and transitions]\label{lemm:fo-and-transitions}
Let $\PP$ and $\PP'$ be $C_\pi$ processes such that $\PP\lts{\alpha}\PP'$. 
\begin{enumerate}
\item If $\alpha=\receive\NK\role\msg\NL$ then $\fo{\PP'}=\fo{\PP}$.
\item If $\alpha=\send\NK\role\msg\NL$ then $\NL\in\fo\PP$ and $\fo{\PP'}\cup\{\NL\} = \fo{\PP}$.
\item If $\alpha=\rest\NL\send\NK\role\msg\NL$ then %$\NL\in\bn\PP$ and 
$\fo{\PP'}\subseteq\fo{\PP}\cup\{\NL\}$.
\item If $\alpha=\tau$ then $\fo{\PP'}\subseteq\fo{\PP}$.
\end{enumerate}
\end{lemma}
\begin{proof}
The proof is by induction on the derivation $\PP\lts{\alpha}\PP'$. 
We will detail only the second and the third statement.
\begin{itemize}
\item [$\mathit{2}.$] For the base case we have that rule \rulename{(out)} must be applied. In that case we have $\PP=\send\NK\role\msg\NL.\PP_1\lts{\send\NK\role\msg\NL}\PP_1=\PP'$. 
Since $\fo{\PP}=\fo{\PP_1}\cup\{\NL\}$ and $\NL\in\fo{\PP}$, by Definition~\ref{def:Cpi_fo}, we may conclude the case.

For the inductive step we have that only rules \rulename{(match)}, \rulename{(res)}, \rulename{(par-l)}, \rulename{(par-r)} and \rulename{(rep-act)} can be applied. We detail only the case of  \rulename{(par-l)}. 
In that case $\PP=\PP_1 \parop \PR \lts{\send\NK\role\msg\NL} \PQ \parop \PR=\PP'$ is derived from $\PP_1 \lts{\send\NK\role\msg\NL} \PQ$, where the side condition of \rulename{(par-l)} is vacuously true since $\bn{\send\NK\role\msg\NL}=\emptyset$. 
By the induction hypothesis we get $\fo{\PQ}\cup\{\NL\}=\fo{\PP_1}$ and $\NL\in\fo{\PP_1}$, and hence by Definition~\ref{def:Cpi_fo} we derive 
$\fo{\PQ \parop \PR}\cup \{\NL\}= \fo{\PQ}\cup \{\NL\} \cup\fo{\PR} =\fo{\PP_1}\cup\fo{\PR}=\fo{\PP_1 \parop \PR} $, 
and $\NL\in\fo{\PP_1}\subseteq\fo{\PP_1 \parop \PR}$.
%
%
\item [$\mathit{3}.$] We only detail the base case, i.e., when rule \rulename{(open)} is applied. 
Then, $\PP=\rest\NL\PP_1\lts{\rest\NL\send\NK\role\msg\NL}\PP'$ is derived from 
$\PP_1\lts{\send\NK\role\msg\NL}\PP'$. 
By the first part of the proof we get $\NL\in\fo{\PP_1}$ and $\fo{\PP'}\cup\{\NL\}=\fo{\PP_1}$. 
Since $\NL\in\bn{\rest\NL\PP_1}$, by Definition~\ref{def:Cpi_bound_names}, we conclude $\fo{\PP'}\subseteq\fo{\rest\NL\PP_1}\cup\{\NL\}$.
\end{itemize}
\end{proof}

What we can conclude from the first statement of Lemma~\ref{lemm:fo-and-transitions} is that if a process receives a channel that is not a free output object of the process, then the received channel also cannot be a free object output in the resulting process. The second statement of the lemma implies that if channel $\NL$ is not free object output of process $\PP$, then process $\PP$ cannot perform an output action with object $\NL$.  
%
%\begin{corollary}\label{cor:fo-and-in-out}
%\begin{enumerate}
%\item If $\PP\lts{\receive\NK\role\msg\NL}\PP'$ and $\NL\notin\fo\PP$ then $\NL\notin\fo{\PP'}$.
%\item If $\NL\notin\fo{\PP}$ then there is no process $\PP'$ and channel $\NK$ such that $\PP\lts{\send\NK\role\msg\NL}\PP'$.
%\end{enumerate}
%\end{corollary}
%
%
Combining the two above statements we may conclude that if a process receives a channel previously not specified as an object of an output prefix in the process, then the received channel will also not appear as an object of an output prefix in the resulting process. We may show that this is preserved also by all possible evolutions of the process. To this end, we first relate the set of free channels appearing in output prefixes of a process and any execution trace. Having this in mind, the next result follows by a direct induction on the size of the trace ($m$). % directly by Lemma~\ref{lemm:fo-and-transitions}.


\begin{corollary}[Free output objects and traces]\label{cor:trace-fo}
Let $\PP, \PP_1,\ldots, \PP_m$ be $C_\pi$ processes. If $\PP\lts{\alpha_1}\PP_1\lts{\alpha_2}\ldots\lts{\alpha_m}\PP_m$ then $\fo{\PP_m}\subseteq\fo{\PP}\cup\bn{\alpha_1}\cup\ldots\cup\bn{\alpha_m}$.
\end{corollary}

The last corollary implies that in the $C_\pi$ model, a process that receives a (fresh) channel name cannot send it later on. To precisely capture this property, we first give a precise definition of non-forwarding for all $\pi$ processes.

\begin{definition}[%Non-Leaking 
Non-forwarding property]\label{def:non-leaking-pi-processes}
A $\pi$ process $\PP_1$ satisfies the non-forwarding %non-leaking 
property if whenever 
\[
\PP_1\lts{\alpha_1}\PP_2\lts{\alpha_2}\ldots\lts{\alpha_{m}}\PP_{m+1}.
\]
where $\NL\notin\fn{\PP_i}$ and $\alpha_i=\receive\NK\role\msg\NL$, for some $i$ in $1, \ldots, m-1$, then $\alpha_j\not=\send{\NK'}\role\msg\NL$, for any channel $\NK'$ and any $j$ in $i+1, \ldots,m$.
\end{definition}

 
The next theorem attests that all $C_\pi$ processes respect the non-forwarding %leaking 
property. %, also in that more rigorous way, where the only restriction for the channel is not to be specified as the free object of any output prefix. 
As we will see in the next section, Definition~\ref{def:non-leaking-pi-processes} will also be used to reason about the non-forwarding of the $\pi$ processes.

\begin{theorem}[Non-forwarding of $C_\pi$ processes]\label{the:non-forwarding}
If $\PP$ is a $C_\pi$ process then $\PP$ satisfies the non-forwarding property.
\end{theorem}

\begin{proof}
Let $\PP=\PP_1$ be a $C_\pi$ process and let
\[
\PP_1\lts{\alpha_1}\PP_2\lts{\alpha_2}\ldots\lts{\alpha_{m}}\PP_{m+1}
\]
We show that if $\NL\notin\fn{\PP_i}$ and $\alpha_i=\receive\NK\role\msg\NL$, for some $i$ in $1, \ldots, m-1$, then $\alpha_j\not=\send{\NK'}\role\msg\NL$, for any channel $\NK'$ and any $j$ in $i+1, \ldots,m$.
Since without loss of generality we can assume all bound outputs are fresh
 and $\NL\notin\fn{\PP_i}$ (therefore $\NL\notin\fo{\PP_i}$), using Corollary~\ref{cor:trace-fo} we get $\NL\notin\fo{\PP_j}$, for $j=i+1, \ldots,m+1$. Hence, applying Lemma~\ref{lemm:fo-and-transitions}, we can conclude $\alpha_j\not=\send{\NK'}\role\msg\NL$, for $j=i+1, \ldots,m$.
%\\
%The proof is by induction on the length of the trace. We detail only the base case. 
%Since $\NL\notin\fn{\PP}$ and $\PP\lts{\receive\NK\role\msg\NL}\PP'$, by Lemma~\ref{lemm:receive-not-in-fo} we get $\NL\notin\fo{\PP'}$. 
%Hence, by Lemma~\ref{lemm:l-not-in-fo-then-no-send-l}, we conclude $\alpha_1\not=\send{\NK'}\role\msg\NL$. 
%If $\PP'\lts{\rest{\NL'}\send{\NK'}\role\msg{\NL'}}\PP_1$, by Lemma~\ref{lemm:fo-and-transitions} we get $\NL'\in\bn{\PP'}$, and without loss of generality we can assume $\NL\not=\NL'$. Thus, we can conclude 
%$\alpha_1\not=\send{\NK'}\role\msg\NL$ and $\alpha_1\not=\rest\NL\send{\NK'}\role\msg\NL$, and since $\NL\notin\fo{\PP'$} by Lemma~\ref{lemm:fo-and-transitions} we have $\NL\notin\fo{\PP_1}$. 
\end{proof}

Notice that, according to discussion preceding Definition~\ref{def:non-leaking-pi-processes}, we could replace the condition $\NL\notin\fn{\PP_i}$ in the definition and in Theorem~\ref{the:non-forwarding} by $\NL\notin\fo{\PP_i}$.
Theorem~\ref{the:non-forwarding} should come as no surprise, the $C_\pi$ syntax is restricted with the goal of excluding forwarding, but nevertheless serves as a rigorous sanity check. On the other hand, if we consider the $\pi$ processes it appears to be nontrivial to differentiate processes that respect the non-forwarding of fresh channel names (cf. Definition~\ref{def:non-leaking-pi-processes}). 
To address this goal, we may rely on comparing $\pi$ processes with $C_\pi$ processes and on the result shown here (see Proposition~\ref{prop:non-forwarding-of-pi-processes}). % o will try to reuse the results developed here by comparing $\pi$-calculus process with $C_\pi$ processes. %in Proposition~\ref{prop:non-forwarding-of-pi-processes}. % to this end. %differentiate such $\pi$-calculus processes. % that respect the non-forwarding. %do not %leak 
%forward names. % (cf. Definition~\ref{def:non-leaking-pi-processes}).
%Notice that condition $\NL\notin\fn{\PP}$ of Lemma~\ref{lemm:receive-not-in-fo} and Theorem~\ref{the:non-forwarding} can be weakened to $\NL\notin\fo{\PP}$. 
%Hence, we may say that the channel received by a process will not be sent afterwards if and only if it was not previously specified as an object of an output prefix. 








\section{Reduction semantics}\label{sec:Cpi-reduction-semantics}

In this section, we present the reduction semantics of the $C_\pi$-calculus, which again follows directly from  the theory developed for the $\pi$-calculus~\cite{pi_calculus}. 
The reduction semantics expresses only internal actions of the processes, and, as we will see, it directly corresponds to the $\tau$ transitions of the labeled transition system introduced in Section~\ref{sec:Cpi-semantics}. The usefulness of the reduction semantics lays in its simplicity and elegance, in particular when used in proofs. This is also the main reason for us to introduce it in this thesis, as we will use the reduction semantics to show the properties of our encoding in Section~\ref{sec:encoding}. 
The simplicity comes from the fact that this semantics relies on the structure congruence relation, that permits for term manipulation, allowing to single out two active prefixes willing to synchronize. 


\begin{table}[t]
\[
\begin{array}{@{}c@{}} 
  \inferrule[(sc-par-inact)]{}
  {\PP\parop\inact\equiv\PP}\qquad
  %
  \inferrule[(sc-par-comm)]{}
  {\PP\parop\PQ\equiv\PQ\parop\PP}\qquad
  %
  \inferrule[(sc-par-assoc)]{}
  {(\PP\parop\PQ)\parop\PR\equiv\PP\parop(\PQ\parop\PR)}
\vspace{2ex} \\
  \inferrule[(sc-res-inact)]{}
  {\rest\NK\inact\equiv\inact}\qquad
  %
  \inferrule[(sc-res-extr)]{}
  {\PP\parop\rest\NK\PQ\equiv\rest\NK(\PP\parop\PQ) \text{  if  } \NK\notin\fn\PP}
\vspace{2ex} \\
  \inferrule[(sc-res-swap)]{}
  {\rest\NK\rest\NL\PP\equiv\rest\NL\rest\NK\PP}\qquad
  %
  \inferrule[(sc-mat)]{}
  {\match\NA\role\msg\NA\pi.\PP\equiv\pi.\PP}\qquad
  %
  \inferrule[(sc-rep)]{}
  {\rep\PP\equiv\; \PP \parop \rep\PP  } 
\end{array}
\]
\caption{\label{tab:Cpi-structural}Structural congruence.}
\end{table}


\begin{table}[t]
\[
\begin{array}{@{}c@{}} 
  \inferrule[(r-comm)]{}
  {\send\NK\role\msg\NL.\PP \parop \receive\NK\role\msg\NX.\PQ \red \PP\parop\PQ\subst{\NL}{\NX}}
\qquad
  \inferrule[(r-par)]{\PP\red \PQ}
  {\PP \parop\PR \red \PQ\parop\PR}
\vspace{2ex} \\
  \inferrule[(r-res)]{\PP\red\PQ}
  {\rest\NK\PP\red\rest\NK\PQ}
\qquad
  \inferrule[(r-stru)]
  {\PP \equiv \PP' \red \PQ' \equiv \PQ}
{\PP \red \PQ}
\end{array}
\]
\caption{\label{tab:Cpi-reduction}Reduction relation.}
\end{table}

\emph{The structural congruence relation}, denoted by $\equiv$, is the least binary congruence on processes that satisfies rules in Table~\ref{tab:Cpi-structural}. Rules \rulename{(sc-par-inact)}, \rulename{(sc-par-comm)} and \rulename{(sc-par-assoc)} make $({\cal \PP}, \parop, \inact)$ a commutative monoid. Rule \rulename{(sc-res-inact)} shows that restricting an inactive process has no effect and that the restriction can be removed. Rule \rulename{(sc-res-extr)} states that if the restricted channel is not specified as free in one of the branches then its scope can be confined only to the other branch, and in the other direction it allows for name extrusion (see the example below). Rule \rulename{(sc-res-swap)}  allows swapping name restrictions, rule \rulename{(sc-mat)} allows to remove the top matching if the names coincide, and rule \rulename{(sc-rep)} states that a copy of the replicated process can be activated in parallel with the replicated one. 


\emph{The reduction relation}, denoted by $\red$, is the least binary relation included in ${\cal \PP}\times{\cal \PP}$ that satisfies the rules given in Table~\ref{tab:Cpi-reduction}. Rule \rulename{(r-comm)} allows for two threads that are running in parallel, one sending and the other receiving on the same channel, to synchronize their actions. Rules \rulename{(r-par)} and \rulename{(r-res)} allow for a reduction to take place under parallel composition and channel restriction, respectively, as prefixes involved in the reduction remain active under these constructs. % (cf. Definition~\ref{def:active_contexts}). 
Rule \rulename{(r-stru)} closes the reduction relation under structural congruence, which thus allows to single out two threads ready to synchronize. 

For the sake of illustration, consider process $\rest\NL\send\NK\role\msg\NL.\inact \parop\receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact$
given in the explanation of rule \rulename{(close-l)} in Section~\ref{sec:Cpi-semantics}. By rule \rulename{(sc-res-extr)} we have
\[
\rest\NL\send\NK\role\msg\NL.\inact \parop\receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact
\equiv
\rest\NL(\send\NK\role\msg\NL.\inact \parop\receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact)
\]
%
Since by \rulename{(r-comm)} $\send\NK\role\msg\NL.\inact \parop\receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact\red \inact \parop\send\NL\role\msg\NM.\inact$ and by \rulename{(r-res)} 
\[
\rest\NL(\send\NK\role\msg\NL.\inact \parop\receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact) \red \rest\NL(\inact \parop\send\NL\role\msg\NM.\inact)
\]
by \rulename{(r-stru)} we conclude
\[
\rest\NL\send\NK\role\msg\NL.\inact \parop\receive\NK\role\msg\NX.\send\NX\role\msg\NM.\inact \red \rest\NL(\inact \parop\send\NL\role\msg\NM.\inact)
\]



As we announced, $\tau$ transitions of the action semantics coincide with reductions of the reduction semantic, up to structural congruence. This is a well-known result for the $\pi$-calculus, cf.~\cite{pi_calculus} Lemma~$1.4.15$, and we may directly state this result for our fragment of the $\pi$-calculus.

\begin{theorem}[Harmony]\label{th:Cpi_harmony}
$\PP\red\PQ$ if and only if there is $\PQ_1$ such that $\PQ_1\equiv\PQ$ and $\PP\lts{\tau}\PQ_1$.
\end{theorem}


We have shown that the set of free object names of a $C_\pi$ process is preserved by $\tau$ transitions in Lemma~\ref{lemm:fo-and-transitions}. Following these lines, we can show that the same property holds in general for $\pi$-calculus processes, by extending Definition~\ref{def:Cpi_fo} to consider free object (channel) names of all $\pi$ processes. In what follows we show that the set of free object names of a $\pi$ process is preserved by structural congruence and is not enlarged by the reduction relation. The reduction semantics of the (sum-free) $\pi$-calculus~\cite{pi_calculus} relies on the same set of rules as in Table~\ref{tab:Cpi-structural} and Table~\ref{tab:Cpi-reduction}, hence we may refer to these rules when dealing with the $\pi$ processes.


\begin{lemma}[Free output objects and reductions]\label{lem:fo_in_equiv_and_red}
Let $\PP$ and $\PQ$ be $\pi$ processes. 
\begin{enumerate}
\item If $\PP\equiv\PQ$ then $\fo{\PQ}=\fo{\PP}$.
\item If $\PP\red\PQ$ then $\fo\PQ\subseteq\fo\PP$.
\end{enumerate} 
\end{lemma}
\begin{proof}
\begin{enumerate}
\item [$\mathit{1}.$] The only structural congruence rule affecting free names is \rulename{(sc-mat)}: $\match\NA\role\msg\NA\pi.\PP\equiv\pi.\PP$, and by the definition $\fo{\match\NA\role\msg\NA\pi.\PP}=\fo{\pi.\PP}$.
%
\item [$\mathit{2}.$] Follows by induction on $\red$ derivation. The base case is when \rulename{(r-comm)} is used. 
Then $\send\NK\role\msg\NL.\PP_1 \parop \receive\NK\role\msg\NX.\PP_2 \red \PP_1 \parop \PP_2\subst{\NL}{\NX}$. 
Since $\fo{\send\NK\role\msg\NL.\PP_1 \parop \receive\NK\role\msg\NX.\PP_2}=\{\NL\}\cup \fo{\PP_1} \cup \fo{\PP_2}$ and $\fo{\PP_1 \parop \PP_2\subst{\NL}{\NX}}\subseteq \fo{\PP_1} \cup (\fo{\PP_2}\setminus\{\NX\}) \cup\{\NL\}$, the case follows. The rest of the cases follow directly from the induction hypothesis and definition of $\fo\PP$, and only in the case of \rulename{(r-stru)} the case $\mathit{1}$. of this lemma is applied.
\end{enumerate}
\end{proof}

The result of the last lemma is used in the proofs of correctness of the encoding of the $\pi$-calculus in the $C_\pi$-calculus, presented in Section~\ref{sec:encoding}.














\section{Behavioral equivalence} \label{sec:Cpi-bisimilarity}

In this section, we introduce a behavioral equivalence relation, called strong bisimilarity. Behavioral equivalences are used to answer the question: in which cases are two systems (processes) indistinguishable when inserted in the same interacting environments~\cite{DBLP:reference/parallel/Nicola11}.
The strong bisimilarity is widely used as (the strictest) equivalence relation to proving properties of processes~\cite{DBLP:series/hhl/BaetenS14, DBLP:journals/toplas/Sangiorgi09, sangiorgi2011introduction}. 
As we will see, the strong bisimilarity relation defined here for the $C_\pi$-calculus in Definition~\ref{def:Cpi-strong-bisimilarity} precisely matches the one of the $\pi$-calculus in~\cite{pi_calculus} Definition~$2.2.1$. Therefore, all the properties for strong bisimilarity relation are inherited, and we fully exploit this convenience to state and explain these properties without giving the proofs, as they can be found in~\cite{pi_calculus}. 

The observable actions introduced in Section~\ref{sec:Cpi-semantics} give a basis to define the strong bisimilarity. % for our model.
Intuitively, two processes are called strongly bisimilar if a game can be played between them: each labeled action of one process can be reproduced by the other process (and inversely), and the resulting processes can be again paired under the same conditions. % are again in the same relation. 
Hence, this relation pairs processes exhibiting the same behavior.

\begin{definition}[Strong bisimilarity]\label{def:Cpi-strong-bisimilarity}
The strong bisimulation is a symmetric relation ${\cal R}$ over processes that satisfies 
\[
\mbox{if}\;\; \PP{\cal R}\PQ \;\;\mbox{and}\;\; \PP\lts{\alpha}\PP', \;\;\mbox{where}\;\; \bn{\alpha}\cap\fn{\PQ}=\emptyset, \;\;\mbox{then}\;\; \PQ\lts{\alpha}\PQ' \;\;\mbox{and}\;\; \PP'{\cal R}\PQ'.
\]
The strong bisimilarity, denoted $\sim$, is the largest strong bisimulation, i.e., it includes all strong bisimulation relations over processes.
\end{definition}

For instance, $\rest\NK\send\NK\role\msg\NL.\PP\sim \inact$, for any process $\PP$, since the left-hand side process cannot exhibit the output action specified in the active prefix because of the side condition of rule \rulename{(res)}. Now consider processes
%
\begin{equation}\label{eq:bismilarity_matching}
\rest\NK(\rest\NL\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\match\NX\role\msg\NM\pi.\inact) \quad \text{and} \quad \rest\NK(\rest\NL\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\inact)
\end{equation}
%
We may show that these two processes are also bisimilar, since 
\[
\begin{array}{rcl}
{\cal R} & = &
\{
(\rest\NK(\rest\NL\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\match\NX\role\msg\NM\pi.\inact),  \rest\NK(\rest\NL\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\inact))\\
& & \;\; (\rest\NK\rest\NL(\inact \parop \match\NL\role\msg\NM\pi.\inact), \rest\NK\rest\NL(\inact \parop\inact))
\}
\end{array}
\]
%
is a strong bisimulation relation. Notice that in process $\match\NL\role\msg\NM\pi.\inact$ the received channel $\NL$ is matched with $\NM$, and since these two names do not coincide the process cannot exhibit the action specified in prefix $\pi$, because of rule \rulename{(match)}. Notice also that $\NL$ is received involving name extrusion since it is bound in the left branch. %, while $\NM$ is free in the right branch of the original process. Our convention (on free and bound names) implies that matching a free with a bound bound name always fails.  %These two examples also hold for any $\pi$-calculus processes. 
% We give a behavioral identity specific for the $C_\pi$-calculus, but before that,  
%A direct consequence of the definition is the next proposition.
%\begin{proposition}\label{prop:Cpi-bisimulation-closure-union}
%The union all strong bisimulations is a strong bisimulation.
%\end{proposition}
%\begin{proof}
%Indeed, if $\PP$ and $\PQ$ are in the relation $\cup {\cal R}$, that is the union of all strong bisimulations, %then there must be some strong bisimulation ${\cal R}$ such that $\PP{\cal R}\PQ$. This attests that each possible action of $\PP$ can be mimicked $\PQ$, and vice versa, and that the resulting processes will be related by ${\cal R}$, and hence also by $\cup {\cal R}$.
%\end{proof}
%This brings us to the relation we are interested in: strong bisimilarity.
%\begin{definition}[Strong Bisimilarity]\label{def:Cpi-strong-bisimilarity}
%The union of all strong bisimulations over $C_\pi$ processes is called strong bisimilarity and is denoted by $\sim$.
%\end{definition}
%By the definition strong bisimilarity is the biggest strong bisimulation relation, and this reflects to 
%the proof method of coinduction which needs to be applied when showing properties of such an object.
We now state some of the fundamental properties of the strong bisimilarity, for which the respective proofs can be found in~\cite{pi_calculus}.

\begin{proposition}[Equivalence]\label{prop:bisimilarity_is_equivalence}
Strong bisimilarity is an equivalence relation.
\end{proposition}

%\begin{proof}
%The reflexivity and symmetry follows directly from the definition of $\sim$. We prove transitivity by coinduction, we define relation
%\[
%{\cal R}=\{(\PP, \PQ) | \;\text{there exists}\; \PR \;\text{such that}\; \PP\sim\PR \; \text{and} \; \PR\sim \PQ\}
%\]
%and we show that ${\cal R}$ is included in strong bisimilarity, i.e., ${\cal R}\subseteq\sim$.
%Assume $\PP\lts{\alpha}\PP'$. 
%Since $\PP{\cal R}\PQ$ it follows there exist $\PR$ such that $\PP\sim\PR$ and $\PR\sim\PQ$.
%By $\PP\sim\PR$ we know there are $\PR'$ such that $\PR\lts{\alpha}\PR'$, where $\bn{\alpha}\cap\fn{\PR}=\emptyset$, and $\PP'\sim\PR'$. By our convention, that bound and free names that are under consideration are always assumed to be distinct, $\bn{\alpha}\cap\fn{\PQ}=\emptyset$ also holds. 
%Then, by $\PR\sim\PQ$ we conclude there is $\PQ'$ such that $\PQ\lts{\alpha}\PQ'$ and $\PR'\sim\PQ'$. From $\PP'\sim\PR'$ and $\PR'\sim\PQ'$ we conclude $\PP'{\cal R}\PQ'$, and the proof follows.
%\end{proof}



%TBC!!!!!!!!!!!!!!!!!!!!

%To show that the replication operator preserves bisimilarity we will introduce a relation of strong bisimulation up to $\sim$.

%\begin{definition}[Bisimulation up to $\sim$]
%Binary relation over processes ${\cal R}$ is called bisimulation up to $\sim$ if it is symmetric and satisfies
%\[
%\mbox{if}\; \PP{\cal R}\PQ \;\mbox{and}\; \PP\lts{\alpha}\PP',  \;\mbox{then}\; \PQ\lts{\alpha}\PQ' \;\mbox{and}\; \PP''{\cal R}\PQ'' \;\mbox{where}\; \PP'\sim\PP'' \;\mbox{and}\; \PQ'\sim\PQ''.
%\]
%\end{definition}

%!!!!!!!!!!!!!!!!!!!!!!!OBJASNI BOLJE!!!!!!!!!!!!!!!!!!!!!!!!!!!

%A direct consequence of the definition and reflexivity of strong bisimulation is that ${\cal R} \subseteq \sim{\cal R}\sim$. Also, if ${\cal R}$ is a strong bisimulation up to $\sim$, then $\sim{\cal R}\sim$ is a strong bisimulation, and hence $\sim{\cal R}\sim\subseteq \sim$. 
%Therefore, to show that some pair of processes $(\PP, \PQ)$ is bisimilar it is enough to show that there is some ${\cal R}$ such that $\PP{\cal R}\PQ$ and that ${\cal R}$ a bisimulation up to $\sim$. 
%Notice, however, that bisimulation up to $\sim$ does not have to be a bisimulation itself.

\begin{proposition}[Structural congruence]\label{prop:Cpi-bisim-standard-props}
If $\PP\equiv\PQ$ then $\PP\sim \PQ$.
\end{proposition}
%\begin{proof}
%TBC!!!!!!!!!!!
%\end{proof}

%TBC!!!!!!!!!!!!!!!
 
\begin{proposition}[Non-input congruence]\label{prop:Cpi_bisim_congruence}
\leavevmode
\begin{itemize}
\item [(a)] If $\PP\sim\PQ$ then
\begin{enumerate}
\item $\PP\parop\PR\sim \PQ\parop\PR$;
\item $\rest\NK\PP\sim\rest\NK\PQ$;
\item $\rep\PP\sim\;\rep\PQ$;
\item if $\pi=\match{\NB_1}\role\msg{\NC_1}\ldots\match{\NB_n}\role\msg{\NC_n}\send\NA\role\msg\NK$ or $\pi=\send\NA\role\msg\NK$ then $\pi.\PP\sim\pi.\PQ$.
\end{enumerate}
\item [(b)] If for any channel $\NK$ it is the case that $\PP\subst{\NK}{\NX}\sim\PQ\subst{\NK}{\NX}$ holds  and $\pi=\match{\NB_1}\role\msg{\NC_1}\ldots\match{\NB_n}\role\msg{\NC_n}\receive\NA\role\msg\NX$ or $\pi=\receive\NA\role\msg\NX$ then $\pi.\PP\sim\pi.\PQ$.
\end{itemize}
\end{proposition}



%The last proposition is a standard property of strong bisimularity: it is preserved by all language constructs, except input prefix, i.e., that it is a non-input congruence. 
The fact that strong bisimilarity is a non-input congruence is inherited from the $\pi$-calculus. It is known that only for some specific sub-calculi of the $\pi$-calculus the strong bisimilarity is preserved by the input construct~\cite{DBLP:journals/acta/BorealeS98,  DBLP:journals/lmcs/HirschkoffP08, DBLP:conf/icalp/HirschkoffP10,  pi_calculus}.
Strong bisimilarity is a non-input congruence in the presence of matching~\cite{DBLP:journals/tcs/BorealeS98}, as it is the case in the $C_\pi$-calculus.
For instance, $\match\NX\role\msg\NM\pi.\inact\sim \inact$, as we already noted in the example above, but  
\[
\receive\NA\role\msg\NX.\match\NX\role\msg\NM\pi.\inact\not\sim \receive\NA\role\msg\NX.\inact
\]
 since it can be the case that the received name is $\NM$, and then the action specified by $\pi$ is activated, while the other process terminates no matter what name is received.

%
%\begin{proof}
%The proof for all cases of $(a)$ proceed by introducing proper witnessing relations, and showing that these are contained in the $\sim$ by coinduction on the definition of strong bisimulation. 
%\begin{enumerate}
%\item We will show that for relation 
%\[
%{\cal R}= \{\big(\rest{\tilde{k}}(\PP \parop \PR),\rest{\tilde{k}}(\PQ \parop \PR)\big) \;|\; \PP\sim\PQ  \}
%\]
%it holds ${\cal R}\subseteq\sim$. 
%Let $(\rest{\tilde{\NK}}(\PP\parop\PR), \rest{\tilde{\NK}} (\PQ\parop\PR))\in{\cal R}$ and let 
%\begin{equation}\label{eq:Cpi_congruence_parallel}
%\rest{\tilde{\NK}}(\PP\parop\PR)\lts{\alpha} \PP_1
%\end{equation} 
%for some $\PP_1$ and $\alpha$, where $\bn{\alpha}\cap\fn{\rest{\tilde{\NK}} (\PQ\parop\PR)}=\emptyset$. 
%We will prove that $\rest{\tilde{\NK}} (\PQ\parop\PR)\lts{\alpha}\PQ_1$ and $(\PP_1,\PQ_1)\in{\cal R}$, for some $\PQ_1$. 
%The proof of the symmetric case, i.e., when the first component of the pair in ${\cal R}$ can emulate the action of the second component is analogous. 
%Here, we distinguish three cases for deriving~(\ref{eq:Cpi_congruence_parallel}), either $\alpha$ originates from $\PP$ or from $\PR$ or from the synchronization between $\PP$ and $\PR$.
%\\
%\emph{-Action of} $\PP:$
%\\
%In this case 
%\[
%\rest{\tilde{\NK}}(\PP\parop\PR)\lts{\alpha}\rest{\tilde{\NK}'}(\PP'\parop\PR)
%\]
%is derived from 
%$\PP\lts{\alpha'}\PP'$,
%by \rulename{(par-l)} and consecutive application of rule \rulename{(res)} and/or \rulename{(open)}.
%If \rulename{(par-l)} and only \rulename{(res)} is applied then
% $\alpha=\alpha'$ and $\tilde{\NK}=\tilde{\NK}'$ and by 
% $\PP\sim\PQ$ we conclude that $\PQ\lts{\alpha'}\PQ'$, where $\PP'\sim\PQ'$. Thus, we can derive 
%\[
%\rest{\tilde{\NK}}(\PQ\parop\PR)\lts{\alpha}\rest{\tilde{\NK}}(\PQ'\parop\PR)
%\]
%If \rulename{(par-l)} and \rulename{(res)} and \rulename{(open)} are applied
%then $\alpha=\rest\NL\send\NM\role\msg\NL$ and $\alpha'=\send\NM\role\msg\NL$ and $\tilde{\NK}=\tilde{\NK}_1,{\NL},\tilde{\NK}_2$ and $\tilde{\NK}'=\tilde{\NK}_1,\tilde{\NK}_2$. 
%Again, by $\PP\sim \PQ$ we can derive 
%\[
%\rest{\tilde{\NK}}(\PQ\parop\PR)\lts{\alpha}\rest{\tilde{\NK}'}(\PQ'\parop\PR)
%\]
%where  $\PP'\sim\PQ'$.
%\\
%\emph{-Action of} $\PR:$ 
%\\
%Follows by similar reasoning.
%\\
%\emph{-Synchronization of} $\PP$ \emph{and} $\PR:$ 
%\\
%We consider only the case when~(\ref{eq:Cpi_congruence_parallel}) is derived using \rulename{(close-l)}. 
%The rest of the cases is analogous.  
%Let us assume
%\[
%\rest{\tilde{\NK}}(\PP\parop\PR)\lts{\tau}\rest{\tilde{\NK}}\rest\NL(\PP'\parop\PR')
%\] 
%is derived from 
%\[
%\PP\lts{\rest\NL\send\NM\role\msg\NL}\PP'
%\qquad \mbox{and} \qquad
%\PR\lts{\receive\NM\role\msg\NL}\PR'.
%\]
%By our convention on free and bound names we can assume $\NL\notin\fn\PQ$, by $\PP\sim\PQ$ we get $\PQ\lts{\rest\NL\send\NM\role\msg\NL}\PQ'$ and $\PP'\sim\PQ'$. 
%Hence, 
%\[
%\rest{\tilde{\NK}}(\PQ\parop\PR)\lts{\tau}\rest{\tilde{\NK}}\rest\NL(\PQ'\parop\PR')
%\] 
%and we may conclude 
%$\big(\rest{\tilde{\NK}}\rest\NL(\PP'\parop\PR'), \rest{\tilde{\NK}}\rest\NL(\PQ'\parop\PR')\big)\in {\cal R}$.
%
%
%\item Follows by similar reasoning, by considering relation
%\[
%{\cal  R}= \{ (\rest\NK\PP, \rest\NK\PQ) \;|\; \PP\sim\PQ \}\; \cup \sim.
%\]
%
%
%\item In this case we proceed by a slightly different argument. We again define a relation 
%\[
%{\cal R}= \{(\PR \parop \rep\PP, \PS\parop\rep\PQ) \;|\; \PR\sim\PS \;\text{and}\; \PP\sim\PQ  \}
%\]
%but, in contrast to other cases, we show that ${\cal R}$ is a strong bisimilarity up to $\sim$.
%
%
%
%Let $(\PR \parop \rep\PP, \PS \parop \rep\PQ)\in {\cal R}$ and let 
%\begin{equation}\label{eq:Cpi_congruence_rep_inp}
%\PR \parop \rep\PP\lts{\alpha}\PP_1
%\end{equation}
%for some $\PP'$ and $\alpha$ such that $\bn{\alpha}\cap\fn{\PS \parop \rep\PQ}=\emptyset$. 
%We distinguish three cases for deriving~(\ref{eq:Cpi_congruence_rep_inp}), either it originates from  $\PR$ or from $\rep\PP$ or from the synchronization between $\PR$ and $\rep\PP$.
%\\
%\emph{-Action of} $\rep\PP:$
%\\
%In this case~(\ref{eq:Cpi_congruence_rep_inp}) is derived by \rulename{(par-r)} and one of the following:
%	\begin{enumerate}
%	\item $\PP_1=\PR\parop\PP'\parop\rep\PP$, where by \rulename{(rep-act)} transition $\rep\PP\lts{\alpha}\PP'\parop\rep\PP$ is derived 
%	from $\PP\lts{\alpha}\PP'$.
%	Since $\PP\sim\PQ$, we get $\PQ\lts{\alpha}\PQ'$ and $\PP'\sim\PQ'$. Hence, by \rulename{(rep-act)} 
%	we can derive 
%	$\rep\PQ\lts{\alpha}\PQ'\parop\rep\PQ$,
%	and by \rulename{(par-r)}
%	\[
%	\PS\parop\rep\PQ \lts{\alpha} \PS \parop\PQ'\parop\rep\PQ.
%	\]
%	By $\PR\sim\PS$ and case 1. of this proposition we get 
%	$\PR\parop\PP' \sim \PS\parop\PP'$ and by $\PP'\sim\PQ'$ we get $\PS\parop\PP'\sim\PS\parop\PQ'$. 
%	Finally, by transitivity of $\sim$  follows $\PR\parop\PP'\sim\PS\parop\PQ'$.
%	Hence,
%	$\big(\PR\parop\PP'\parop\rep\PP, \PS\parop\PQ'\parop\rep\PQ\big)\in{\cal R}$.
%	%
	%
%	\item $\PP_1=(\PP' \parop \PP'') \parop \rep\PP$, where 
%	$\rep\PP\lts{\tau}(\PP' \parop \PP'') \parop \rep\PP$ is derived by \rulename{(rep-comm)} from 
%	$\PP\lts{\send\NK\role\msg\NL}\PP'$ and $\PP\lts{\receive\NK\role\msg\NL}\PP''$. 
%	Since $\PP\sim\PQ$ it follows $\PQ\lts{\send\NK\role\msg\NL}\PQ'$, where $\PP\sim\PQ'$, 
%	and $\PQ\lts{\receive\NK\role\msg\NL}\PQ''$, where $\PP''\sim\PQ''$. 
%	Hence, by \rulename{(rep-comm)} and \rulename{(par-r)} we derive 
%	\[
%	\PS\parop\rep\PQ \lts{\tau} \PS\parop (\PQ' \parop \PQ'')\parop \rep\PQ.
%	\]
%	Since $\PP'\sim\PQ'$ and $\PP''\sim\PQ''$, by $1.$ of this proposition and 
%	transitivity of $\sim$ we get $\PR\parop (\PP'\parop\PP'') \sim \PS\parop(\PQ'\parop\PQ'')$.
%	%
%	%
%	\item $\PP_1=\rest\NL(\PP' \parop \PP')\parop \rep\PP$ where  \rulename{(rep-close)} is applied, 
%	follows similar reasoning.
%	\end{enumerate}
%
%\emph{-Synchronization between} $\PR$ \emph{and} $\rep\PP:$
%\\
%We detail only the case when 
%\rulename{(close-l)} is applied. In this case 
%\[
%\PR \parop \rep\PP \lts{\tau} \rest\NL(\PR' | \PP') \parop \rep\PP 
%\]
%is derived from 
%\[
%\PR\lts{{\rest\NL}\send\NK\role\msg\NL}\PR' \quad \mbox{and} \quad \rep\PP\lts{\receive\NK\role\msg\NL}\PP' \parop \rep\PP,
%\]
%where the latter is derived from $\PP\lts{\receive\NK\role\msg\NL}\PP'$.
%Since by our convention on free and bound names we can assume $\NL\notin\fn{\PS \parop \rep\PQ}$, by $\PR\sim\PS$ we derive $\PS\lts{{\rest\NL}\send\NK\role\msg\NL}\PS'$, where $\PR'\sim\PS'$.
%Also, from $\PP\sim\PQ$ we have $\PQ\lts{\receive\NK\role\msg\NL}\PS'$ and $\PP'\sim\PS'$.
%Then, by \rulename{(rep-act)}, \rulename{(close-l)} we can also derive
%\[
%\PS \parop \rep\PQ \lts{\tau} \rest\NL(\PS' | \PQ' \parop \rep\PQ).
%\]
%Since $\NL\notin\fn{\rep\PQ}$, by Proposition~\ref{prop:Cpi-bisim-standard-props} we get 
%$\rest\NL(\PS' | \PQ' \parop \rep\PQ)\sim\rest\NL(\PS' | \PQ') \parop \rep\PQ$. 
%By $\PP'\sim\PQ'$ and $\PR'\sim\PS'$ and $1.$, $2.$ of this proposition and transitivity of $\sim$ we get 
%$\rest\NL(\PR'\parop\PP')\sim\rest\NL(\PS'\parop\PQ')$.
%\\
%\emph{Observation on} $\PR:$
%\\
%
%
%
%
%
%\end{enumerate} 
%\end{proof}
%
%
%Notice that relation ${\cal R}$ in $1.$ of the proof is bigger that one might at first expect, since restrictions for arbitrary channels $\tilde{k}$ are scoping over related processes. 
%This saturation of the relation is, however, needed. 
%For example, consider that  process $\rest\NL\send\NK\role\msg\NL.\inact$ when places in parallel with $\receive\NK\role\msg\NX.\inact$ may interact 
%\[
% \rest\NL\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\inact
% \lts{\tau}
% \rest\NL(\inact \parop \inact)
%\]
%Hence, some restrictions of parallel processes may ``float up" to the point of their synchronization. 
%Similarly for other cases, e.g., in $2.$ the relation had to be saturated with $\sim$, for rule \rulename{(open)}.



We now present one behavioral equality that is specific for the $C_\pi$-calculus. 
We have shown that the processes given in~(\ref{eq:bismilarity_matching}) are bisimilar, and we commented there that if the received name is new to the process then matching it with any name of the process will always fail. What specifically holds in the $C_\pi$-calculus is that if a process sends a bound name, after which receives a name and matches it with the name previously sent (like in $\rest\NL\send\NK\role\msg\NL.\receive\NK\role\msg\NX.\match\NX\role\msg\NL\pi.\PP$), the matching will always fail. The reason is the non-forwarding property of $C_\pi$ processes: a process that receives $\NL$ will never be able to send it later on.
We exploit this feature in the next result to directly represent the creation of closed domains for channels, that resembles the creation of secure channels with statically determined scope. % can be formalized using  the strong bisimilarity relation.

\begin{proposition}[Closed domains for channels]\label{prop:behavioural}
For any $C_\pi$ process $\PP$, channel $\NM$ and prefix $\pi$, the following equality holds

\[
\rest\NK
%\rest\NM  
( \rest\NL\send\NK\role\msg\NL.\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \receive\NK\role\msg\NX.\PP)
\sim 
\rest\NK
%\rest\NM  
( \rest\NL\send\NK\role\msg\NL.\receive\NM\role\msg\NY.\inact \parop \receive\NK\role\msg\NX.\PP)
\]

\end{proposition}
%
\begin{proof}
The proof is by coinduction on the definition of the strong bisimulation, by showing that the relation 
\[
\begin{array}[t]{@{}rcl@{\;\;}l@{}}
{\cal R} & =  & \{ \big(
\rest\NK
%\rest\NM  
( \rest\NL\send\NK\role\msg\NL.\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \receive\NK\role\msg\NX.\PP), 
\rest\NK
%\rest\NM  
( \rest\NL\send\NK\role\msg\NL.\receive\NM\role\msg\NY.\inact \parop \receive\NK\role\msg\NX.\PP)
\big),  \\
          &   & \;\; \big(
\rest\NK\rest\NL
%\rest\NM  
( \receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PQ), 
\rest\NK \rest\NL
%\rest\NM  
( \receive\NM\role\msg\NY.\inact \parop \PQ)
\big), \\
          &   & \;\; \big(
\rest\NL
%\rest\NM  
( \receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PQ), 
 \rest\NL
%\rest\NM  
( \receive\NM\role\msg\NY.\inact \parop \PQ)
\big), \\
          &   & \;\; \big(
\rest\NK \rest\NL
%\rest\NM  
( \match\NN\role\msg\NL\pi.\inact \parop \PQ), 
\rest\NK \rest\NL
%\rest\NM  
(\inact \parop \PQ)
\big), \\
          &   & \;\; \big(
\rest\NL
%\rest\NM  
( \match\NN\role\msg\NL\pi.\inact \parop \PQ), 
 \rest\NL
%\rest\NM  
 (\inact \parop \PQ)
\big),\\
          &   & \;\; \big(
\rest\NK \rest\NL \rest\NN
%\rest\NM  
( \match\NN\role\msg\NL\pi.\inact \parop \PQ), 
\rest\NK \rest\NL \rest\NN
%\rest\NM  
(\inact \parop \PQ)
\big), \\
          &   & \;\; \big(
\rest\NL \rest\NN
%\rest\NM  
( \match\NN\role\msg\NL\pi.\inact \parop \PQ), 
 \rest\NL \rest\NN
%\rest\NM  
 (\inact \parop \PQ)
\big) \\
&   & \;\;\parop \mbox{for all}\; \NN,\NM\in\Chn, \; \mbox{such that} \; \NN\not=\NL, \\
&   & \;\;\;\;\hbox{ and all processes}\; \PP \; \mbox{and} \;  \PQ, \; \hbox{such that} \; \NL\notin\fo\PQ\,\}
\end{array}
\]
is a strong bisimulation, hence, contained in strong bisimilarity (i.e., ${\cal R}\subseteq \sim$).

We show that each action of one process can be mimicked by the other process in the pair in $\cal R$, 
leading to 
processes that are again in relation $\cal R$. 
Let the process in the first pair
\[
\rest\NK
%\rest\NM  
( \rest\NL\send\NK\role\msg\NL.\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \receive\NK\role\msg\NX.\PP)\lts{\alpha} \PP'
\]
%
Then, since actions of the starting process can only be actions of its two branches,
we conclude that either $\alpha=\rest\NL\send\NK\role\msg\NL$ or $\alpha=\receive\NK\role\msg\NN$ or 
it is the synchronization of these two actions, in which case $\alpha=\tau$. 
We reject the first two options since the subject of the action is bound in the starting process and by 
rule \rulename{(res)} it cannot be observed outside of the process.
Hence, we conclude $\alpha=\tau$ and $\PP'=\rest\NK \rest\NL(\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PP\subst\NL\NX)$. 
Then, by applying \rulename{(out)}, \rulename{(open)}, \rulename{(in)}, \rulename{(close-l)} and \rulename{(res)}, respectively, we observe 
\[
\rest\NK
%\rest\NM  
( \rest\NL\send\NK\role\msg\NL.\receive\NM\role\msg\NY.\inact \parop \receive\NK\role\msg\NX.\PP)
\lts{\tau} 
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\inact \parop \PP\subst\NL\NX)
\]
%
and since $\NL\notin\fn\PP$ and $\NX$ cannot appear as an object 
in the prefixes in $\PP$ we conclude $\NL\notin\fo{\PP\subst\NL\NX}$. 
Hence,  we have 
\[
\big(\rest\NK \rest\NL(\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PP\subst\NL\NX),
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\inact \parop \PP\subst\NL\NX)\big)\in{\cal R}
\]
The symmetric case is analogous.

Now let us consider processes in the second pair of $\cal R$. 
If 
\[
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PQ)\lts{\alpha}\PP'
\]
%
then the observable $\alpha$ can originate from one of the branches or from their synchronization.

\;\emph{---Left branch:}\; 
If the observable originate from the left branch, then $\alpha=\receive\NM\role\msg\NN$, and by 
\rulename{(in)}, \rulename{(par-l)} and \rulename{(res)}  
%
\[
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PQ)
\lts{\receive\NM\role\msg\NN} 
\rest\NK \rest\NL(\match\NN\role\msg\NL\pi.\inact \parop \PQ)
\]
%
where, by the side condition of \rulename{(res)} we conclude $\NN\notin\{\NK, \NL\}$.
In the same we derive 
%
\[
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\inact \parop \PQ)
\lts{\receive\NM\role\msg\NN}
\rest\NK \rest\NL(\inact \parop \PQ)
\]
%
and 
$\big(\rest\NK \rest\NL(\match\NN\role\msg\NL\pi.\inact \parop \PQ), 
\rest\NK \rest\NL(\inact \parop \PQ)\big)\in{\cal R}$ holds.

\;\emph{---Right branch:}\;
If the action originates from the right branch, i.e., 
from $\PQ \lts{\alpha} \PQ'$,
we distinguish two cases:
\begin{itemize}
\item [(i)] if the derivation is carried out using rules \rulename{(par-r)} and \rulename{(res)} we have that
%
\[
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PQ)
\lts{\alpha} 
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PQ')
\]
%
where, since $\NL\notin\fo{\PQ}$, by Lemma~\ref{lemm:fo-and-transitions} we conclude $\NL\notin\fo{\PQ'}$.
Then, by the same rules  
%
\[
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\inact \parop \PQ)
\lts{\alpha} 
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\inact \parop \PQ')
\]
%
and 
$\big(\rest\NK \rest\NL(\receive\NM\role\msg\NY.\match\NN\role\msg\NL\pi.\inact \parop \PQ'),
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\inact \parop \PQ')\big)\in{\cal R}$ holds.
\item [(ii)] if the derivation is carried out using rules \rulename{(par-r)}, \rulename{(res)} and \rulename{(open)} we have that 
%
\[
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PQ)
\lts{\rest\NK\alpha} 
\rest\NL(\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PQ')
\]
then $\NL\notin\n\alpha$. 
Notice that the scope of channel $\NL$ cannot be opened this way since 
$\NL\notin\fo\PQ$.
%from $\NL\notin\fn\PP$ we can conclude 
%that $\NL$ cannot be an object of output prefix in $\PP\subst\NL\NX$. 
Hence, process $\PQ$ cannot 
perform output action with object $\NL$.
Then by the same rules  
%
\[
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\inact \parop \PQ)
\lts{\rest\NK\alpha} 
 \rest\NL(\receive\NM\role\msg\NY.\inact \parop \PQ')
\]
%
and, again, 
$\big( \rest\NL(\receive\NM\role\msg\NY.\match\NN\role\msg\NL\pi.\inact \parop \PQ'),
 \rest\NL(\receive\NM\role\msg\NY.\inact \parop \PQ')\big)\in{\cal R}$ holds.
\end{itemize} 
%
%Notice that for any process $\PP$, if $\PP\lts{\alpha}\PP'$ and $\NL\notin\fo\PP$, we can show that $\NL\notin\fo{\PP'}$, for any possible action $\alpha$.

\;\emph{---Synchronization of branches:}\;
We again distinguish two cases:
\begin{itemize}
\item [(i)] if the derivation follows from 
%
\[
\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact\lts{\receive\NM\role\msg\NN}\match\NN\role\msg\NL\pi.\inact \qquad \mbox{and} \qquad 
\PQ\lts{\send\NM\role\msg\NN}\PQ'
\]
%
where we can make the same observation on $\PQ$ as before to conclude that $\NL\not=\NN$, 
and the derivation relies on rules \rulename{(comm-r)} and \rulename{(res)} hence
%
\[
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PQ)
\lts{\tau}
\rest\NK \rest\NL(\match\NN\role\msg\NL\pi.\inact \parop \PQ')
\]
%
Then, considering $\receive\NM\role\msg\NY.\inact\lts{\receive\NM\role\msg\NN}\inact$,
and the same rules as above we have that
%
\[
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\inact \parop \PQ)
\lts{\tau}
\rest\NK \rest\NL(\inact \parop \PQ')
\]
%
and $\big( \rest\NK \rest\NL(\match\NN\role\msg\NL\pi.\inact \parop \PQ'),
\rest\NK \rest\NL(\inact \parop \PQ')\big)\in{\cal R}$.
\item [(ii)] 
if the derivation follows from 
%
\[
\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact\lts{\receive\NM\role\msg\NN}\match\NN\role\msg\NL\pi.\inact \qquad \mbox{and} \qquad 
\PQ\lts{\rest\NN\send\NM\role\msg\NN}\PQ'
\]
%
where %without loss of generality 
as before we can assume $\NL\not=\NN$,  
and derivation relies on rules \rulename{(close-r)} and \rulename{(res)} hence
%
\[
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PQ)
\lts{\tau}
\rest\NK \rest\NL\rest\NN(\match\NN\role\msg\NL\pi.\inact \parop \PQ')
\]
%
then using $\receive\NM\role\msg\NY.\inact\lts{\receive\NM\role\msg\NN}\inact$,
we may observe
%
\[
\rest\NK \rest\NL(\receive\NM\role\msg\NY.\inact \parop \PP)
\lts{\tau}
\rest\NK \rest\NL\rest\NN(\inact \parop \PQ')
\]
%
and $\big( \rest\NK \rest\NL\rest\NN(\match\NN\role\msg\NL\pi.\inact \parop \PQ'),
\rest\NK \rest\NL\rest\NN(\inact \parop \PQ')\big)\in{\cal R}$.
\end{itemize}

The symmetric cases and the rest of the pairs from $\cal R$ are analogous. 
For the rest of the pairs note that in all of them the left branch that appears on the left-hand side of the pairs we have 
$\match\NN\role\msg\NL\pi.\inact$, where $\NN\not=\NL$, and hence, it exhibits no transitions and is observationally equivalent to the inactive process $\inact$, which appears in the left branch in the right-hand side of the pairs.


%OR, TO SHORTEN THE NOTATION:

%\[
%\begin{array}[t]{@{}rcl@{\;\;}l@{}}
%{\cal R} & =  & \{ \big(
%\rest\NK 
%( \rest\NL\send\NK\role\msg\NL.\receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \receive\NK\role\msg\NX.\PP), 
%\rest\NK 
%( \rest\NL\send\NK\role\msg\NL.\receive\NM\role\msg\NY.\inact \parop \receive\NK\role\msg\NX.\PP)
%\big),  \\
%          &   & \;\; \big(
%\rest\NK^i\rest\NL 
%( \receive\NM\role\msg\NY.\match\NY\role\msg\NL\pi.\inact \parop \PP\subst\NL\NX), 
%\rest\NK^i \rest\NL  
%( \receive\NM\role\msg\NY.\inact \parop \PP\subst\NL\NX)
%\big), \\
%          &   & \;\; \big(
%\rest\NK^i \rest\NL \rest\NN^j 
%( \match\NN\role\msg\NL\pi.\inact \parop \PP\subst\NL\NX), 
%\rest\NK^i \rest\NL \rest\NN^j 
%(\inact \parop \PP\subst\NL\NX)
%\big)
%\},
%\end{array}
%\]
%where $\NN\not=\NL$ and $i,j\in\{0,1\}$, is contained in the strong bisimilarity, i.e., ${\cal R}\subseteq \sim$.
\end{proof}
%


In both processes related by strong bisimilarity in Proposition~\ref{prop:behavioural} the left thread creates a new channel $\NL$ and sends it to the right thread over a channel $\NK$ that is known only to the two threads. 
The bisimilarity shows that then the channel $\NL$ cannot be received afterwards in the left thread. 
As discussed above, this is a consequence of the non-forwarding property of $C_\pi$ processes.
Furthermore, we may show that channel $\NL$ will not be exchanged even between sub-processes of process $\PP\subst{\NL}{\NX}$ (as there would exist a sub-process that violates the non-forwarding property). 
Hence, in this constellation, channel $\NL$ will be sent only once and afterwards have a ``static" nature since then it can be used only for sending and receiving along the channel and cannot be sent itself. 
We say that the two processes given in the proposition determine a closed domain for channel $\NL$. 
%The interpretation of this proposition can be twofold. 
%On one hand, the right thread after receiving a fresh channel ($\NL$) cannot send the received channel, 
%which we call 
%since it respects the non-forwarding %\new{leaking} 
%property.
%On the other hand, %since 
%the left thread sends the channel $\NL$ (to the right thread) only once 
%the scope of 
%and the channel afterward behaves ``statically", since then it cannot be exchanged even between any two sub-processes of process $\PP\subst{\NL}{\NX}$. %by any process.
%is statically determined since the threads receiving a fresh channel cannot send it afterwards. 
%Further explanations are given in the next section.



\subsection{Strong barbed equivalence}\label{sec:strong_barbed_equivalence}
For the purpose of the results in Section~\ref{sec:encoding}, we introduce a behavioral equivalence that relies on the reduction relation instead of the labeled transitions. To this end, we introduce the notion of barbs and strong barbed equivalence. Again we fully exploit the theory developed for the $\pi$-calculus in~\cite{pi_calculus}, where all the details and poofs can be found.  

\begin{definition}[Barbs]
For each channel $\NK$ and process $\PP$, we say that $\PP\downarrow_{\overline{\NK}}$ holds if $\PP$ can perform an output action with subject $\NK$, and $\PP\downarrow_\NK$ holds is $\PP$ can perform an input action with subject $\NK$.
\end{definition}

Based on the definition of barbs, we define the strong barbed bisimilarity.

\begin{definition}[Strong barbed bisimilarity]
Strong barged bisimilarity is the largest symmetric relation $\dot\sim$ such that if $\PP\;\dot\sim\;\PQ$ then 
\begin{enumerate}
\item if $\PP\downarrow_\NK$ then $\PQ\downarrow_\NK$,
\item if $\PP\downarrow_{\overline{\NK}}$ then $\PQ\downarrow_{\overline{\NK}}$,
\item if $\PP\red\PP'$ then $\PQ\red\PQ'$ and $\PP'\;\dot\sim\;\PQ'$.
\end{enumerate}
\end{definition}

The strong barbed  bisimilarity is not a congruence relation, it is not even preserved by parallel composition. For instance, 
\[\send\NK\role\msg\NL.\send\NN\role\msg\NM.\inact \;\dot\sim\; \send\NK\role\msg\NL.\inact
\] 
while 
$\send\NK\role\msg\NL.\send\NN\role\msg\NM.\inact \parop \receive\NK\role\msg\NX.\inact$ and  $\send\NK\role\msg\NL.\inact \parop \receive\NK\role\msg\NX.\inact$ are not strong barbed bisimilar since after the reduction the first process has barb $\NN$. The relation we are interested in, and that coincides with the strong bisimilarity, closes the strong barbed bisimilarity under parallel composition contexts.
\begin{definition}
Two processes $\PP$ and $\PQ$ are strong barbed equivalent, $\PP\simeq\PQ$, if for any $\PR$ holds $\PP\parop\PR\;\dot\sim\;\PQ\parop\PR$. 
\end{definition}

The proof of the next theorem can be found in~\cite{pi_calculus} Theorem~$2.2.9(1)$.

\begin{theorem}[Strong characterization]\label{th:strong_characterization}
$\PP\simeq\PQ$ if and only if $\PP\sim\PQ$.
\end{theorem}

As noted, we are going to use strong barbed equivalence formally in the proofs in Section~\ref{sec:encoding}, where we are going to deal with the reduction relation. However, notice that the strong bisimilarity relation offers a much more tractable technique for proving that two processes are related, since relating two processes with strong barbed equivalence requires that they have to be tested when composed in parallel with an infinite number of processes (actually, all of them).


\subsection{A characterization of the non-forwarding $\pi$ processes}\label{sec:the_non-forwarding_of_pi_processes}

We have seen in Theorem~\ref{the:non-forwarding} that $C_\pi$ processes satisfy Definition~\ref{def:non-leaking-pi-processes}: if the received channel is fresh to the process it will not be forwarded. 
Considering $\pi$ processes, the non-forwarding property, in general, does not hold, so this kind of privacy property is hard to guarantee. 
Therefore, it may be worthwhile to develop a method for distinguishing the $\pi$-calculus processes that satisfy the non-forwarding property relying on the $C_\pi$-calculus developed here.
If we focus only on the $\pi$ processes that are closed, i.e., do not have free names, we may notice that these processes vacuously satisfy non-forwarding.
Furthermore, we may find examples of $\pi$ processes that are not part of the $C_\pi$ syntax and not closed but still respect this property. 
For instance, $\pi$ process 
\[
\receive\NK\role\msg\NX.\rest\NL(\send\NL\role\msg\NX.\inact \parop \receive\NL\role\msg\NY.\inact)
\]
that receives a channel on $\NK$ and then sends the received channel on $\NL$. However, since $\NL$ is restricted in the process, the received channel will be exchanged only between the components of the process and will not be sent to the process environment. However, statically characterizing the non-forwarding by considering that forwarding is performed only on restricted channels is not possible, as restricted channels can be opened. For instance, we may notice that $\pi$ process 
$\receive\NK\role\msg\NX.\rest\NL(\send\NK\role\msg\NL.\send\NL\role\msg\NX.\inact \parop \receive\NL\role\msg\NY.\inact)$ 
does not satisfy the non-forwarding %leaking 
property.

Hence, differentiating a non-forwarding $\pi$ process may not be an easy task. 
Here, we propose a method towards the solution of this problem. One may observe that if a $\pi$ process $\PP$ is bisimilar to some $C_\pi$ process $\PQ$, then $\PP$ must satisfy the non-forwarding property (Definition~\ref{def:non-leaking-pi-processes}).
This is the idea of our next proposition. 
%, for which we are going to consider the non-forwarding %leaking property of Definition~\ref{def:non-leaking-pi-processes}, extended to all $\pi$-calculus processes. 
We remark that since we are dealing with sum-free $C_\pi$ process, in the proposition we consider also only sum-free $\pi$ terms. Also, in the next proposition we use Definition~\ref{def:Cpi-strong-bisimilarity} extended here to consider the strong bisimilarity relation over all $\pi$ processes (as in~\cite{pi_calculus}).


\begin{proposition}[Non-forwarding $\pi$ processes]\label{prop:non-forwarding-of-pi-processes}
Let $\PP$ be a %(sum-free) 
$\pi$ process. If there is a $C_\pi$ process $\PQ$, such that $\PP\sim\PQ$, then $\PP$ satisfies the non-forwarding %leaking 
property.

%Let $\PPP_1$ be a sum-free $\pi$-calculus process and let 
%\[
%\PPP_1\lts{\alpha_1}\PPP_2\lts{\alpha_2}\ldots\lts{\alpha_{m}}\PPP_{m+1}.
%\]
%If there is a $C_\pi$ process $\PQ_1$, such that $\PPP_1\sim\PQ_1$, then if $\NL\notin\fn{\PPP_i}$ and $\alpha_i=\receive\NK\role\msg\NL$, for some $i=1, \ldots, m-1$, then $\alpha_j\not=\send{\NK'}\role\msg\NL$ and $\alpha_j\not=\rest\NL\send{\NK'}\role\msg\NL$, for all $j=i+1, \ldots,m$.
\end{proposition}

\begin{proof}
Let $\PP_1=\PP$ be a (sum-free) $\pi$ process and let $\PP_1\lts{\alpha_1}\PP_2\lts{\alpha_2}\ldots\lts{\alpha_{m}}\PP_{m+1}.$
Let us fix $i\in\{1,\ldots, m-1\}$, and assume $\NL\notin\fn{\PP_i}$ and $\alpha_i=\receive\NK\role\msg\NL$. Since without loss of generality we can assume all bound outputs are fresh, we get $\alpha_j\not=\rest\NL\send{\NK'}\role\msg\NL$, for all $j=i+1, \ldots,m$, directly. 
In addition to the first assumption, let us assume there is $j\in\{i+1, \ldots,m\}$ such that $\alpha_j=\send{\NK'}\role\msg\NL$. 
Since $\PP_1\sim\PQ_1$ (where $\PQ_1=\PQ$), we conclude there are $C_\pi$ processes $\PQ_2, \ldots, \PQ_{m+1}$ such that
\[
\PQ_1\lts{\alpha_1}\PQ_2\lts{\alpha_2}\ldots\lts{\alpha_{m}}\PQ_{m+1}
\] 
and $\PP_n\sim\PQ_n$, for all $n=1,\ldots,m+1$, where $\PQ_i\lts{\receive\NK\role\msg\NL}\PQ_{i+1}$ and $\PQ_j\lts{\send{\NK'}\role\msg\NL}\PQ_{j+1}$. 
We now distinguish two cases.
\begin{enumerate}
\item If $\NL\notin\fn{\PQ_i}$ then we get a direct contradiction with Theorem~\ref{the:non-forwarding}. 
\item If $\NL\in\fn{\PQ_i}$, we choose a fresh channel $\NL'$ and a substitution $\sigma$ that is defined only on channel $\NL$ and maps it to $\NL'$. Then, from $\PP_j\lts{\alpha_j}\PP_{j+1}$, by consequitive application of~\cite{pi_calculus} Lemma~$1.4.8$, we conclude $(\PP_j)\sigma\lts{(\alpha_j)\sigma}(\PP_{j+1})\sigma$, for all $j=i+1, \ldots,m$. Since $\NL\notin\fn{\PP_i}$ we get $(\PP_i)\sigma=\PP_i$.
Now from 
\[
\PP_1\lts{\alpha_1}\ldots\lts{\alpha_{i-1}}\PP_i\lts{(\alpha_i)\sigma}(\PP_{i+1})\sigma\lts{(\alpha_{i+1})\sigma}\ldots\lts{(\alpha_{m})\sigma}(\PP_{m+1})\sigma,
\]
and $\PP_1\sim\PQ_1$, we again conclude there are $C_\pi$ processes $\PQ_2, \ldots, \PQ_{m+1}$ such that
\[
\PQ_1\lts{\alpha_1}\ldots\lts{\alpha_{i-1}}\PQ_i\lts{(\alpha_i)\sigma}\PQ_{i+1}\lts{(\alpha_{i+1})\sigma}\ldots\lts{(\alpha_{m})\sigma}\PQ_{m+1},
\]
where $\PP_j\sim\PQ_j$, for all $j=1,\ldots,i$ and $(\PP_j)\sigma\sim\PQ_j$, for all $j=i+1,\ldots,m+1$. 
Since $\NL'$ has been chosen to be a fresh channel, we get $\NL'\notin\fn{\PQ_i}$, and since  $\PQ_i\lts{\receive{(\NK)\sigma}\role\msg{\NL'}}\PQ_{i+1}$ and $\PQ_j\lts{\send{(\NK')\sigma}\role\msg{\NL'}}\PQ_{j+1}$, we fall into the first case, and hence, we again get contradiction with Theorem~\ref{the:non-forwarding}. 

\end{enumerate}
\end{proof}

Proposition~\ref{prop:non-forwarding-of-pi-processes} opens a number of possible direction for improvements and modifications.
For instance, Proposition~\ref{prop:non-forwarding-of-pi-processes} shows that if a $\pi$ process  is bisimilar to a $C_\pi$ process then it does respect non-forwarding, but it does not give an algorithm for deriving the respective $C_\pi$ process. 
%However, we believe that Proposition~\ref{prop:non-forwarding-of-pi-processes} provides a step towards such a result. 
Also, we can relax the definition of the non-forwarding, to consider processes that do not forward names received only on some predefined set of channels. Another point is answering the question if a $\pi$ process respects the non-forwarding property if and only if is bisimilar to a $C_\pi$ process.  Such investigations are left for future work.




