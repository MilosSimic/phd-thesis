%!TEX root =  main.tex
\section{Extended example}\label{sec:BYOL_example}

This section presents an example motivated by the \emph{Bring Your Own License} (BYOL)
notion, that should provide further insights in our model and our type discipline, and also to provide a link to 
a relevant domain in practice.
The BYOL is a licensing model that is closely related  to the cloud-based based computing. The cloud computing provides on-demand availability of resources, such as deploying and running applications, data storage, etc. Typically, these resources can be accessed by many users (over the internet), but are not directly maintained by users. The core of the BYOL model is that it provides flexibility to a user that is willing to deploy a software 
application in the cloud to also deploy his own license. Here, we  can recognize the pattern of delegation, as the user can lose the ability to run the application elsewhere by deploying his license in the cloud.
% owned by the user so as to allow the application to run in the cloud. 

To provide a proper mindset, let us consider an example in which a $\mathit{Company}$ is willing to deploy
a $\mathit{query}$ service (that may require some exhaustive computations) in the cloud 
and to store the resulting data on a 
cloud database. For instance, $\mathit{Company}$ may consider offers from two cloud service providers, 
Amazon Web Service ($\mathit{AWS}$) and IBM Cloud ($\mathit{IBM}$), and is licensed to use  Microsoft Azure SQL Database ($\mathit{SQL}$).
We may then model this scenario with
%
$$ \mathit{Company} \parop \mathit{AWS} \parop \mathit{IBM} \parop \mathit{SQL}$$
%
where we consider processes can run concurrently.
The communication protocol of the two providers $\mathit{AWS}$ and $\mathit{IBM}$ may be represented as
%
$$\mathit{AWS}=\repreceive{{\mathit{aws}}}\role\msg{\mathit{service}}.\rauth{\mathit{aws}}\role\msg{\mathit{service}}.\send{\mathit{service}}\role\msg{\mathit{data}}.\inact$$
%.\receive{\mathit{task}}\role\msg{\mathit{data}}.\send{\mathit{aws}}\role\msg{\mathit{result}}$$
$$\mathit{IBM}=\repreceive{{\mathit{ibm}}}\role\msg{\mathit{service}}.\rauth{\mathit{ibm}}\role\msg{\mathit{service}}.\send{\mathit{service}}\role\msg{\mathit{data}}.\inact$$
%.\receive{\mathit{task}}\role\msg{\mathit{data}}.\send{\mathit{ibm}}\role\msg{\mathit{result}}$$
%
specifying that the providers can repeatably receive a $\mathit{service}$ name, 
and then to receive the respective authorization, which would allow for the provider to use $\mathit{service}$ for sending
%and receive 
some data. % along the same $\mathit{service}$ name. 
%At the end of the protocol the result of the computation is sent.
We abstract here from the computation task itself, given that we focus exclusively on the
communication pattern, so running the $\mathit{service}$ amounts to sending the 
$\mathit{data}$.

We now model $\mathit{Company}$ by specifying two managers and two workers that run concurrently. A manager should decide which service provider is to be 
used and a worker is responsible for interaction with the providers. %, corresponding to the managers decisions. 
Therefore, we define
%
$$\mathit{Company}= \scope{\mathit{query}}^2\scope{\mathit{ibm}}^2\scope{\mathit{aws}}^2(\mathit{Manager} \parop \mathit{Manager} \parop \mathit{Worker} \parop \mathit{Worker})$$
%
where the company owns two of each of authorizations to interact with services $\mathit{IBM}$ and $\mathit{AWS}$ and with the database center $\mathit{SQL}$
(through $\mathit{query}$). 
%We use exponents to abbreviate that the company has two of such authorizations each.
Consider that a manager's decision of which cloud service should be used
depends on the quality of service $(\mathit{qos})$, and  
that the manager notifies a worker about the decision via channel $\mathit{choice}$. 
For the purpose of modeling this process, we make a simple extension of our  language with a 
conditional statement ``if then else''. Therefore,
%
$$
%\begin{array}{ll}
\mathit{Manager}  =  \scope{\mathit{choice}}
 \; \mbox{if} \;(\mathit{qos}) \; \mbox{then} \; \send{\mathit{choice}}\role\msg{\mathit{aws}}.\inact \;\mbox{else}\; \send{\mathit{choice}}\role\msg{\mathit{ibm}}. \inact
%\end{array}
$$
%
%where $i=1,2$, denoting both managers with the same process.
Once a manager has made the decision and notified the worker by sending the name of the chosen service provider, one of the workers receives the name and then 
sends $\mathit{query}$ and the respective authorization to the provider
%Afterwards, the worker waits to receive the result of the computation,
%
$$\mathit{Worker}= \scope{\mathit{choice}} \receive{\mathit{choice}}\role\msg{\mathit{csp}}. \send{{\mathit{csp}}}\role\msg{\mathit{query}}. \sauth{\mathit{csp}}\role\msg{\mathit{query}}.\inact$$
%
%where $i=1,2$, i.e., both workers are also modeled with the same process.
We may notice that the authorization for $\mathit{query}$ is at first implicitly available for the whole 
$\mathit{Company}$ and that a $\mathit{Worker}$ will grab and explicitly delegate the authorization 
 in order to allow the provider to use $\mathit{query}$.
%the $\mathit{Worker}$s after sending the name $\mathit{query}$ also send
%the respective authorization. 
Also, two of each of authorizations for $\mathit{aws}$ and $\mathit{ibm}$ are originally available to all processes in the domain of the company, hence the two $\mathit{Manager}$s
can choose the two providers
can be used zero, one or two times. %, hence the need for the $\mathit{Company}$ to hold two authorizations on each. 
In any of the four cases, the $\mathit{query}$ is used exactly 
twice (by each of the two $\mathit{Worker}$s).

We model the cloud database so as to be able repeatably to receive a request along $\mathit{query}$, hence
%
$$
\mathit{SQL}= \repreceive{{\mathit{query}}}\role\msg\NX.%\send{\mathit{service}}\role\msg{\mathit{data}}.
\inact
$$
%
For the sake of simplicity, we abstract away from possible later interactions, 
since these may also require isolation (e.g., via dedicated private channels).

We now observe possible interactions in the system. 
Consider that one of the $\mathit{Manager}$s makes a decision to use $\mathit{ibm}$ service provider and sends the name to one of the $\mathit{Worker}$s. 
If we assume a usual extension of the LTS with rules to deal with the ``if then else'' statement by considering the evolution, via a $\tau$ transition, to the $\mathit{then}$ branch when the condition is true, and otherwise to the $\mathit{else}$ branch, together with \rulename{(l-out)} and \rulename{(l-scope-ext)} we may derive
%
$$\mathit{Manager}\lts{\tau}\lts{
\send{\mathit{choice}}\role\msg{\mathit{ibm}}} 
\scope{\mathit{choice}}\inact$$
% 
%where $\mathit{Manager'}=\scope{\mathit{choice}}\; \mbox{if} \;(\mathit{qos}) \; \mbox{then} \;  \send{\mathit{choice}}\role\msg{\mathit{aws}} \;\mbox{else}\; \send{\mathit{choice}}\role\msg{\mathit{ibm}}$.
Then, one of the $\mathit{Worker}$s performs the (authorized )reception by 
 rules \rulename{(l-in)} and \rulename{(l-scope-ext)}
%
$$\mathit{Worker}\lts{\receive{\mathit{choice}}\role\msg{\mathit{ibm}}}\mathit{Worker'}$$
%
where 
$\mathit{Worker'}=\scope{{\mathit{choice}}}\send{{\mathit{ibm}}}\role\msg{\mathit{query}}. \sauth{{\mathit{ibm}}}\role\msg{{\mathit{query}}}.\inact%.\receive{{\mathit{ibm}}}\role\msg{\mathit{result}}
$.
The two dual actions along $\mathit{choice}$ can then synchronize when the two processes are composed in parallel. Thus, by rule \rulename{(l-comm)} we have
%
$$\mathit{Manager} \parop \mathit{Worker}\lts{\tau} \lts{\tau} \scope{\mathit{choice}}\inact \parop \mathit{Worker'}$$
%
Now, the decision has been made, and $\mathit{Worker'}$ can send the request to the chosen provider by rule \rulename{(l-out)}
%
$$\mathit{Worker'}\lts{{\scope{\mathit{ibm}}}\send{\mathit{ibm}}\role\msg{\mathit{query}}}
\mathit{Worker''}$$
%
where $\mathit{Worker''}=\scope{{\mathit{choice}}}\scope{\mathit{ibm}} \sauth{{\mathit{ibm}}}\role\msg{{\mathit{query}}}.\inact.$ %\receive{{\mathit{ibm}}}\role\msg{\mathit{result}}$.
We may observe that the action is not authorized for name $\mathit{ibm}$, that is confined to $\mathit{Worker''}$ as the result of the transition. 
However, it becomes authorized at the level of the company where the authorization is floating 
$$ 
\begin{array}{c}
\scope{\mathit{query}}^2\scope{\mathit{ibm}}^2\scope{\mathit{aws}}^2(\mathit{Manager} \parop \scope{\mathit{choice}}\inact \parop \mathit{Worker'} \parop \mathit{Worker})\\
\lts{\send{\mathit{ibm}}\role\msg{\mathit{query}}}
\\
\scope{\mathit{query}}^2\scope{\mathit{ibm}}\scope{\mathit{aws}}^2(\mathit{Manager} 
\parop \scope{\mathit{choice}}\inact \parop \mathit{Worker''} \parop \mathit{Worker})
\end{array}
$$ 
by rules \rulename{(l-scope-ext)}, \rulename{(l-par)} and \rulename{(l-scope)}. 
%%
%
Following the same reasoning, the company, via process $\mathit{Worker''}$, can delegate authorization for $\mathit{query}$ on channel $\mathit{ibm}$, as by
 rule \rulename{(l-out-a)}
%
$$\mathit{Worker''} \lts{{\scope{\mathit{query}}}\sauth{\mathit{ibm}}\role\msg{\mathit{query}}}
\scope{{\mathit{choice}}}\scope{\mathit{ibm}}.\inact$$
%
%where, $\mathit{Worker_1'''}=\scope{{\mathit{choice}}}\scope{\mathit{ibm}} \receive{{\mathit{ibm}}}\role\msg{\mathit{result}}$.
and by rules \rulename{(l-par)}, \rulename{(l-scope-ext)} and \rulename{(l-scope)}, 
we may derive
%
$$ 
\begin{array}{c}
\scope{\mathit{query}}^2\scope{\mathit{ibm}}\scope{\mathit{aws}}^2(\mathit{Manager} 
\parop \scope{\mathit{choice}}\inact \parop \mathit{Worker''} \parop \mathit{Worker})
\\
\lts{\sauth{\mathit{ibm}}\role\msg{\mathit{query}}}
\\
\scope{\mathit{query}}\scope{\mathit{ibm}}\scope{\mathit{aws}}^2(\mathit{Manager} \parop \scope{\mathit{choice}}\inact \parop \scope{{\mathit{choice}}}\scope{\mathit{ibm}}\inact \parop \mathit{Worker})
\end{array}$$
%
causing the $\mathit{Company}$
 to lose one authorization for $\mathit{query}$.

The $\mathit{IBM}$ process first receives name $\mathit{query}$, and then receives the authorization, by 
 the rules \rulename{(l-in-rep)},  \rulename{(l-in-a)},  \rulename{(l-scope-ext)} and 
\rulename{(l-par)}
%
$$
\mathit{IBM}
 \lts{\receive{\mathit{ibm}}\role\msg{\mathit{query}}} 
 \lts{\rauth{\mathit{ibm}}\role\msg{\mathit{query}}}
\mathit{IBM'},
$$
%
where $\mathit{IBM'}= \mathit{IBM} \parop \scope{{\mathit{query}}}\scope{\mathit{ibm}}\send{\mathit{query}}\role\msg{\mathit{data}}.\inact.$
%\receive{\mathit{service}}\role\msg{\mathit{data}}.\send{\mathit{ibm}}\role\msg{\mathit{result}}.$
Finally, the service provider $\mathit{IBM'}$ is connected with $\mathit{SQL}$ through channel $\mathit{query}$ and also authorized to use the channel. Hence, $\mathit{IBM'}$ can send the $\mathit{data}$ to $\mathit{SQL}$.
 % and finish this example interaction.  

We may now attest that the above scenario contains no errors by applying our typing analysis. % we can now statically confirm the absence of errors in the  presented scenario, 
We assume an additional typing rule that deals with the conditional statement
in a standard way: both branches  and the whole conditional should have the same type. Let us consider the type assignments collected in a typing environment
%
$$
\begin{array}{lll}
\Delta & = & 
 \mathit{aws}:\{\mathit{aws}\}(T),\\
& & \mathit{ibm}:\{\mathit{ibm}\}(T), \\
& & \mathit{query}: T,\\
& & \mathit{choice}:\{\mathit{choice}\}(\{\mathit{aws}, \mathit{ibm}\}(T))
\end{array}
$$
%
where $T=\{\mathit{query}\}(\{\mathit{data}\}(\emptyset))$.
We can then check  
%
$$\Delta \vdash_\emptyset \mathit{Company} \parop \mathit{AWS} \parop \mathit{IBM} \parop \mathit{SQL}$$
%
Thus, the system is well-typed and owns enough authorizations, so it never gets stuck.

We may now derive
%
$$\Delta \vdash_\rho \mathit{Worker}$$
%
where $\rho=\{\mathit{query}, \mathit{ibm}, \mathit{aws}\}$.
Let us recall  
%
$$\mathit{Worker}= \scope{\mathit{choice}} \receive{\mathit{choice}}\role\msg{\mathit{csp}}. \send{{\mathit{csp}}}\role\msg{\mathit{query}}. \sauth{\mathit{csp}}\role\msg{\mathit{query}}.\inact.$$
%
Since rule \rulename{(t-stop)} claims that the inactive process can be typed by any assumptions, we may observe
%
$$\Delta, \mathit{csp}:\{\mathit{aws}, \mathit{ibm}\}(T) \vdash_{\rho_1} \inact$$
%
where $\rho_1=\{\mathit{choice}, \mathit{ibm}, \mathit{aws}\}$. 
Then, by rule \rulename{(t-deleg)}, we may derive
%
$$\Delta, \mathit{csp}:\{\mathit{aws}, \mathit{ibm}\}(T) \vdash_{\rho_1, \{\mathit{query}\}} \sauth{\mathit{csp}}\role\msg{\mathit{query}}.\inact$$
%
since all replacements for $\mathit{csp}$ given in its type ($\{\mathit{aws}, \mathit{ibm}\}$) are contained in $\rho_1$,
%(hence if $\{\mathit{aws}, \mathit{ibm}\} \subseteq \{\mathit{choice}, \mathit{ibm}, \mathit{aws}\}$), 
to which we add the name of the delegated authorization in the conclusion. %, since the authorization is . 
The added name ensures that the process must be placed in 
a context that provides all the necessary authorizations.
If we now apply rule \rulename{(t-out)}, we observe
%
$$\Delta, \mathit{csp}:\{\mathit{aws}, \mathit{ibm}\}(T) \vdash_{\rho_1, \{\mathit{query}\}} \send{{\mathit{csp}}}\role\msg{\mathit{query}}.\sauth{\mathit{csp}}\role\msg{\mathit{query}}.\inact$$
%
where we again have the same check for $\mathit{csp}$ 
(now considering $\rho_1,\{\mathit{query}\}$), 
and we also check that all possible replacements for 
$\mathit{query}$, which is only $\mathit{query}$ itself, are contained in the carried type of 
$\mathit{csp}$, which holds since $T=\{\mathit{query}\}(\{\mathit{data}\}(\emptyset))$. 
Then, by \rulename{(t-in)} 
%
$$\Delta \vdash_{\rho_1, \{\mathit{query}\}} \receive{\mathit{choice}}\role\msg{\mathit{csp}}.\send{{\mathit{csp}}}\role\msg{\mathit{query}}.\sauth{\mathit{csp}}\role\msg{\mathit{query}}.\inact$$
%
since $\mathit{choice}$ is in $\rho_1,\{\mathit{query}\}$ 
and the type of $\mathit{csp}$ is 
equal to the carried type of $\mathit{choice}$.
Finally, by \rulename{(t-auth)} we conclude
%
$$\Delta \vdash_\rho \mathit{Worker}$$
%
where $\rho$ is obtained from $\rho_1,\{\mathit{query}\}$ by removing $\mathit{choice}$.
Hence, each $\mathit{Worker}$ is safe if placed in a context
that provides authorizations for names $\mathit{query}$, $\mathit{ibm}$, and $\mathit{aws}$.
We remark that authorizations for $\mathit{ibm}$ and $\mathit{aws}$ will not be both actually needed since only one of them can be received in $\mathit{choice}$. However, to ensure any possible evolution of
the system is safe, both authorizations (for $\mathit{ibm}$ and $\mathit{aws}$) must be
 provided.



\section{Towards applications}\label{sec:go_program}


This section provides an intuition of how our model can lead to developments in a practical setting. 
Specifically, we consider an extension of a programming language that 
embeds the principles presented in this work. 
We remark that authorizations and many other security concerns
are often handled separately with respect to the application layer.
However, it may be the case that the application domain and the security concerns are closely entangled. Thus, establishing the correspondence between application requirements 
and security layer guarantees, in general, may not be a trivial task.
For instance, a resource management can be tightly related to the application 
due to service contracts that are subject to optimization by the application business logic. 
Providing programming language direct support for the resource management in such cases might be an important  solution.
%
Following these lines, we believe introducing programming language support for our notion of floating authorizations  can produce some benefits in practice.

To illustrate the idea let us consider Figure~\ref{fig:goprogram} that presents the code of a program written in Go. Here, the language of Go is endowed
with a construct \lstinline{auth( )} that represents our authorization scoping construct. The construct is used in lines 12, 17, 18, 22, 29, 34, and 38, and marked with the comment \lstinline{//} \lstinline{Language extension}).
The program represents the $\mathit{Company}$ process described in Section~\ref{sec:BYOL_example}, simplified here by considering there is only one manager thread that sends a channel to two worker threads. % a channel 
%they can use to communicate. 
For simplicity, we only use anonymous goroutines for which the intended authorization scoping is given directly by the syntax.
%For simplicity, in particular to what concerns appropriate handling of authorization scoping, 

\begin{figure}
\begin{lstlisting}[frame=single]
package main

import "fmt"

func main() {
	choice := make(chan chan string)
	aws := make(chan string)
	ibm := make(chan string)

	// MANAGER
	go func() {
		auth(choice) // Language extension
		choice <- aws
		choice <- ibm
	}()

	auth(ibm) // Language extension
	auth(aws) // Language extension

	// WORKER 1
	go func() {
		auth(choice) // Language extension
		csp := <-choice
		csp <- "worker1"
	}()

	// WORKER 2
	go func() {
		auth(choice) // Language extension
		csp := <-choice
		csp <- "worker2"
	}()

	auth(aws) // Language extension
	msg1 := <-aws
	fmt.Println("aws", msg1)

	auth(ibm) // Language extension
	msg2 := <-ibm
	fmt.Println("ibm", msg2)

}
\end{lstlisting}
\caption{Example Extended Go Program}
\label{fig:goprogram}
\end{figure}

First, the program creates three channels \lstinline{choice}, \lstinline{aws}, and \lstinline{ibm} with the proper type
assignments (lines 6-8).  Channel \lstinline{choice} can be used to communicate messages of type \lstinline{chan} \lstinline{string}, meaning that \lstinline{choice} is used to communicate channel endpoints
that can be used to communicate strings. Types of \lstinline{aws} and \lstinline{ibm} specify that these two channels can be used to communicate strings. %After which 
After that, in lines 11-15, a goroutine, that represents a manager process,
is defined and directly invoked so as to spawn a thread that will run the code given in the body of the routine, in lines 12-14. Specifically, in line 12 an authorization for 
channel \lstinline{choice} is created, after which in lines 13 and 14 channel endpoints for \lstinline{aws} and \lstinline{ibm}, respectively, are sent via channel \lstinline{choice}. We may observe that the manager thread is self-sufficient in terms of authorizations as both communications are carried out using channel \lstinline{choice}, for which the respective authorization is present. 

The main thread continues to lines 17 and 18 where the authorizations for \lstinline{aws} and \lstinline{ibm} are created.
%after which 
Then, in lines 21-25 and 28-32 the goroutines for two worker threads the defined and invoked. 
 The code for the workers specifies the creation of an authorization for channel \lstinline{choice} in lines 22 and 29, after which in lines 23 and 30 the reception of
a channel on channel \lstinline{choice} is performed, and finally the emission of a text message on the received channel is conducted in lines 24 and 31.
The main thread then carries out the receptions of the text messages in lines 35 and 39, for which the respective authorizations are provided in lines 34 and 38, and finally, 
their onscreen display in lines 36 and 40.

We may observe that the two workers receive the \lstinline{aws} and \lstinline{ibm} endpoints on channel \lstinline{choice}
sent by the manger. Thus, the workers output the text messages (lines 24 and 31) on the \lstinline{aws} and \lstinline{ibm} channels. 
Notice that the two authorizations for \lstinline{aws} and \lstinline{ibm} are created in the main thread (lines 17-18). Hence, these are floating over both worker threads spawned by the goroutine invocation, 
and each one of the authorizations can be confined to either one of the threads. Also, we may observe that each worker thread receives a different channel and which one is
not prescribed by the code. Therefore, \lstinline{"worker1"} can be sent on \lstinline{aws} and \lstinline{"worker2"} on \lstinline{ibm}, or \lstinline{"worker2"} can be sent on \lstinline{aws} and \lstinline{"worker1"} on \lstinline{ibm}.
In both cases, the program can be considered as authorization safe since the respective floating authorization can be confined to the thread at the moment it uses the channel.

We may now consider refinements of the resource management in the context of this simple example. If channel endpoints are subject to a rigorous
accounting, for instance, according to an established service contract (for instance, with third parties, such as Amazon or IBM, where the number of active channel 
endpoints may be restricted), it is important to have language mechanisms that give direct support to conform to the service contract. The 
creation of the authorizations in lines 17-18 gives a precise operational specification of the resources available. Notice that we could also reason
on authorization reception replacing the creation in lines 17-18 so as to, for instance, rely on a communication with the service provider to establish the 
authorizations. Furthermore, the floating authorizations provide the flexibility for the resources to be accessible among concurrent threads
while keeping track of the resource control. 

We can also build on our typing analysis to devise static verification techniques that can ensure programs like the one shown never get stuck due to lacking authorizations. 
However, notice that a direct application of our typing discipline would exclude the example given in Figure~\ref{fig:goprogram}, since in the carried type of channel \lstinline{choice} both \lstinline{aws} and \lstinline{ibm} names would have to be mentioned, as both indeed can be communicated in the channel. Following these lines, to ensure that both workers do not lack authorizations we would require
two authorizations for each \lstinline{aws} and \lstinline{ibm}. We conceive that our typing analysis can be extended so as to address this configuration
and, moreover, that our language principles can already be used as the basis for runtime verification techniques that would allow to transparently run the example program.
We also conceive that our language principles can be embedded in a programming language by means of a specialized API, instead of a proper extension, relying on the 
appropriate library calls for authorization creation and resource usage, up to some ingenuity for authorization scoping. We do retain the necessity of considering specialized
language constructs for the sake of the dedicated theoretical investigation presented in this thesis.

