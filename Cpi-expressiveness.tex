%!TEX root =  main.tex
\section{Examples}\label{sec:examples}


This section presents several examples as a showcase of the possible usefulness of the $C_\pi$-calculus. 
We may notice that a $C_\pi$ process that creates a channel always keeps for himself the capability of sending the channel while the other processes that learn about the channel by receiving it can only use the channel to communicate on it. Hence, between the processes in which a channel is known, we may distinguish 

\begin{itemize}
\item \emph{administrators}, the processes that create the channel: these have the capabilities of communicating on the channel and also sending the channel;
\item \emph{users}, the processes that at some point have received the channel: these have only the capabilities of communicating on the channel.
\end{itemize}

As the capability of sending a channel is never transferred between processes, we can conclude that none of the channel users can become an administrator for the channel, and furthermore, only administrators can engage new users (but not administrators) by sending the channel.  
%We can also notice that the administrators of the channel are also users but the inverse is not true. 

Let us consider the process given at the beginning of this chapter 
%, extended here with another process
\[
(\rest{\mathit{session}}\send{\mathit{chn}}\role\msg{\mathit{session}}.\mathit{Alice}) \parop \receive{\mathit{chn}}\role\mgs{\NX}.\mathit{Bob} \parop \receive{\mathit{forward}}\role\msg\NY.\mathit{Carol}
\]
adapted here by considering $\mathit{Alice}, \mathit{Bob}$ and $\mathit{Carol}$ to be $C_\pi$ processes.
Then, the administrator of $\mathit{session}$ is the process in the scope of the name restriction, while $\mathit{Bob}$ becomes a user after the initial synchronization. 
In our model, $\mathit{Bob}$ cannot send $\mathit{session}$ to a third party afterwards. 
Considering that $\mathit{Bob}$ wants to send to $\mathit{Carol}$ one end-point of channel $\mathit{session}$, he first needs to notify the administrator, in this case $\mathit{Alice}$, by connecting her with $\mathit{Carol}$.  
Hence, we can have 
\begin{itemize}
\item $\mathit{Bob}=\send{\mathit{channel}}\role\msg{\mathit{forward}}.\inact$, where $\mathit{Bob}$ sends to $\mathit{Alice}$ channel $\mathit{forward}$ and then terminates,
\item $\mathit{Alice}=\receive{\mathit{channel}}\role\msg\NY.\send{\NY}\role\msg{\mathit{session}}.\mathit{Alice'}$, where $\mathit{Alice}$ receives the channel from $\mathit{Bob}$ and decides to send $\mathit{session}$ along the received channel, and
\item finally, $\mathit{Carol}$ can receive $\mathit{session}$ along channel $\mathit{forward}$ directly from $\mathit{Alice}$.
\end{itemize} 
This example shows that in the $C_\pi$ any channel extrusion first has to be ``approved'' by the channel administrators. 
%We remark this example is not restricted to binary session types setting, as three or more processes can communicate on $\mathit{session}$. What is seems interesting is the correlation of the control on linear usages of channels that session types impose and the control over usages of channels that is deduced from the $C_\pi$-calculus. We leave such investigations for future work.



\subsection{Authentication}\label{sec:authentication}

We stipulated that specifying $\rest{\mathit{session}}\mathit{Alice}$ in the $C_\pi$-calculus defines $\mathit{
Alice}$ as the administrator for channel $\mathit{session}$. Administrator (process $\mathit{Alice}$) can extrude the scope of the channel ($\mathit{session}$) by sending it, but the receiving processes will only become users and never administrators for the received channel. 
The administrator attribute is something that remains with the creator of the channel and is invariant to process evolution. 
This locality can be used for authentication of processes as follows. 
Assume process $\mathit{Bob}$ is a user of channel $\mathit{session}$. Then, $\mathit{Bob}$ can test the other process with whom he is communicating on $\mathit{session}$ to determine if the other process is an administrator of the channel.
For example, we can specify
\[
\mathit{Bob}=\rest{\mathit{privateChn}}\send{\mathit{session}}\role\msg{\mathit{privateChn}}.\receive{\mathit{privateChn}}\role\msg\NX.\match\NX\role\msg{\mathit{session}}.\mathit{Bob}'
\]
where process $\mathit{Bob}$ first establishes a private connection with the other process listening on $\mathit{session}$ by sending fresh $\mathit{privateChn}$. Afterwards, $\mathit{Bob}$ specifies an input and then matches the received name with $\mathit{session}$. If the received channel is $\mathit{session}$ then the other process, say $\mathit{Alice}$, has proven to $\mathit{Bob}$ that she is in the domain where $\mathit{session}$ was created.
% an administrator for the channel, and hence, that $\PR$ is the (part of) process that created channel $\NL$.

A similar scenario can be used by two administrators of the channel to test each other. 
For instance, we can have process
%
\[
 \send{\mathit{chn}}\role\msg{\mathit{session}}.\receive{\mathit{chn}}\role\msg\NY.\match\NY\role\msg{\mathit{session}}\pi.\mathit{Alice}
\parop
\receive{\mathit{chn}}\role\msg\NX.\match\NX\role\msg{\mathit{session}}\send{\mathit{chn}}\role\msg{\mathit{session}}.\mathit{Dylan}
\]
%
where the two threads first perform a kind of authentication scheme and only then activate $\pi.\mathit{Alice}$ and $\mathit{Dylan}$ and their possible interactions.  
First, the right thread receives a name and matches it with $\mathit{session}$, i.e., we get 
\[
\receive{\mathit{chn}}\role\msg\NY.\match\NY\role\msg{\mathit{session}}\pi.\mathit{Alice}
\parop
\match{\mathit{session}}\role\msg{\mathit{session}}\send{\mathit{chn}}\role\msg{\mathit{session}}.\mathit{Dylan}'
\]
where $\mathit{Dylan}'=\mathit{Dylan}\subst{\mathit{session}}{\NX}$, and since the received name is $\mathit{session}$ then he sends the channel by himself. 
The left thread receives the name and also matches it with $\mathit{session}$, i.e., we obtain process $\match{\mathit{session}}\role\msg{\mathit{session}}\pi'.\mathit{Alice}'
\parop
\mathit{Dylan}'$, where $\pi'.\mathit{Alice}'=(\pi.\mathit{Alice})\subst{\mathit{session}}{\NY}$. 
Since the received name is $\mathit{session}$, $\mathit{Alice}'$ continues interacting with $\mathit{Dylan}'$. After this testing, both threads have proven to be administrators for the channel.% and that they both originate from process $\PP$.





\subsection{Modeling groups and name hiding}\label{sec:groups}


The channel creation construct of the $\pi$-calculus introduces a notion of a private resource. %representation. 
This private resource can be shared with other processes through scope extrusion, and this is a very important aspect of the $\pi$-calculus. On the other hand, extruding the scope means exposing the private resource to others. We have seen that the $C_\pi$-calculus does not prevent the scope extrusion, but it simply confines (with the process that creates the channels) this capability. 

Several process models have been proposed for controlling the channel sharing in the $\pi$-calculus. The paper by Cardelli et al.~\cite{cardelli05}, extends the $\pi$-calculus syntax with the construct for group creation. 
A type is assigned to each channel, specifying to which group that channel belongs. 
The operational semantics instrumented with the type information ensures that channels of a group cannot be acquired by a process outside the scope of the group. Furthermore, their typing discipline provides that grouped channels are never communicated on open channels. 
The work of Giunti et al.~\cite{Giunti} extends the syntax of the $\pi$-calculus with a construct called hide. 
The hide construct has similar properties as channel restriction, but it is more rigorous since construct hide does not allow for scope extrusion. Hence, a name specified in the hide construct has a predetermined scope. 

Determining the scope of a channel can be achieved in $C_\pi$-calculus directly, as already hinted in~Proposition~\ref{prop:behavioural}. For instance, if the channel creation is placed in a separate thread and then sent to a process, as in

\[
\rest{\mathit{chn}} 
( \rest{\mathit{session}}\send{\mathit{chn}}\role\msg{\mathit{session}}.\inact \parop \receive{\mathit{chn}}\role\msg\NX.\mathit{Group}_\NX)
\]
then, after the initial synchronization channel $\mathit{session}$ will have the final scope determined by $\mathit{Group}_\mathit{session}$. 
This is simply a consequence of $\mathit{Group}_\mathit{session}$ being a $C_\pi$-process, and not being capable to send channels that were received. 
Furthermore, since the resulting process is $\rest{\mathit{chn}} 
\rest{\mathit{session}}(\inact \parop \mathit{Group}_\mathit{session})$, we may notice that channel $\mathit{session}$ actually loses its mobility altogether and behaves more like a $CCS$ channel~\cite{DBLP:books/sp/Milner80}. Notice that the administrator is now the inactive process so the capability of sending the name is lost. Hence, the scope of a channel can be permanently restricted this way, but differs when comparing to groups and name hiding where a channel can be communicated inside a predefined scope since in our case the channel cannot be communicated in any process. 

We may try to get closer to represent groups and name hiding by combining the channel creation and authentication from Section~\ref{sec:authentication}. 
The capability of sending a channel is always kept local with the administrator of the channel. 
We may use this fact to localize the final scope for a protected channel. 
For instance, we may say that in process
\[
\rest{\mathit{group}} (\rest{\mathit{session}}\mathit{Alice} \parop \mathit{Bob})
\]
channel $\mathit{session}$ can be received only by administrators of channel ${\mathit{group}}$, which represents the group which may have access to channel ${\mathit{session}}$. %(process $(\rest{\mathit{session}}\mathit{Alice} \parop \mathit{Bob}))$. 
To this end, each time channel $\mathit{session}$ is to be sent by process $\mathit{Alice}$, she must authenticate the receiving process as an administrator for channel ${\mathit{group}}$, by specifying
\[
\rest{\mathit{privateChn}} \send{\mathit{chn}}\role\msg{\mathit{privateChn}}. \receive{\mathit{privateChn}}\role\msg\NX. \match\NX\role\msg{\mathit{group}} \send{\mathit{privateChn}}\role\msg{\mathit{session}}
\]
This way we can ensure channel $\mathit{session}$ will be received only by a process that originates from $\rest{\mathit{session}}\mathit{Alice} \parop \mathit{Bob}$. 
Comparing again with groups and name hiding we see that now we do have channel mobility only inside a predefined scope. However, in the presence of attackers (that are not $C_\pi$ processes), this mechanism needs to be further strengthened to protect also the channels that represent groups, such as channel $\mathit{group}$. We leave this exploration and formalization of the relationship between $C_\pi$ and models with groups and name hiding for future  work.

 

\subsection{Open-ended groups}\label{sec:open-ended-groups}

All examples of restricting channel sharing we have considered so far have used a predefined scope for a protected channel. This is also the case with works with groups~\cite{cardelli05} and name hiding~\cite{Giunti}, in which the scope of channels that are confidential are statically prescribed. 
However, we may notice that sometimes protected resources need to be shared in open-ended environments and that the above limitation can be considered too restrictive. 
We believe that the $C_\pi$-calculus, with its administrator-user hierarchy, offers a good base to reason on open-ended groups. 
For instance, consider process
\[
\rest{\mathit{session}} (\send{\mathit{chn}}\role\msg{\mathit{session}}.\mathit{Alice} \parop \mathit{Bob}) \parop \receive{\mathit{chn}}\role\msg\NX.\mathit{Carol}
\] 
where the leftmost thread is the administrator for channel $\mathit{session}$, $\mathit{Bob}$ is a user, and $\mathit{Carol}$ does not know name $\mathit{session}$. 
The administrator (i.e., the process that created the group), can send the name of the group to other processes, and hence can engage new users to the group, in our example obtaining 
\[
\rest{\mathit{session}} (\mathit{Alice} \parop \mathit{Bob} \parop \mathit{Carol}')
\]
where $\mathit{Carol}'=\mathit{Carol}\subst{\mathit{session}}{\NX}$. Notice that the control of joining new users to the group is handled by an administrator, as users cannot themselves engage other members to the group.
















\section{Encoding forwarding}\label{sec:encoding}


Even though the specification power of $C_\pi$-calculus is clearly different from the $\pi$-calculus, this is not the case when comparing the expressiveness of the computational models. In this section, we show how the $\pi$-calculus can be implemented (encoded) in the $C_\pi$-calculus which therefore informs on the expressive power of the language. The section is divided into three parts. The first part informally introduces  the idea of the encoding, Section~\ref{subsec:the_encoding} formally presents the encoding and Section~\ref{subsec:Cpi_operational_correspondence} provides the proof of the Operational correspondence result.
%
%(nu c) (c?x.x!a) | (nu b)c!b
%For the last example of 
%The $C_\pi$-calculus restricts  the syntax of the $\pi$-calculus by disabling forwarding, but as we will show in this section it does not restrict the expressiveness of the $\pi$-calculus. 
%

As the number of different process models has grown, comparing these various models in a systematic way has been recognized as an important aspect of the research in the field~\cite{DBLP:journals/entcs/Parrow08}. There are a number of important results among which are: encoding the $\lambda$-calculus into the $\pi$-calculus~\cite{DBLP:journals/mscs/Milner92}, comparing various subcalculi of the $\pi$-calculus~\cite{ DBLP:journals/tcs/Boreale98, DBLP:conf/ecoop/HondaT91, DBLP:journals/iandc/NestmannP00}, comparing different process calculi and some separation results~\cite{ DBLP:journals/njc/CarboneM03,DBLP:journals/iandc/DardhaGS17, DBLP:journals/corr/DedeicPP15, DBLP:journals/iandc/Gorla10, DBLP:journals/iandc/LanesePSS11,   DBLP:conf/rc/MedicM16,DBLP:journals/mscs/Palamidessi03, DBLP:conf/lics/PalamidessiSVV06, DBLP:phd/ethos/Sangiorgi93}.
We start this section with an informal presentation of the idea, and afterwards, we present an encoding from the $\pi$-calculus into our calculus and we attest the encoding is valid by showing the operational correspondence result, following the criteria given in~\cite{DBLP:journals/iandc/Gorla10}.

In order to represent our encoding in a more compact way we use a fragment of the polyadic version of our calculus. 
The only difference of the syntax of the polyadic $C_\pi$ with the syntax introduced in Section~\ref{sec:Cpi-syntax} is that the output ($\send\NK\role\msg\NL$) and the input ($\receive\NK\role\msg\NX$) prefix can have as object a tuple of names. Hence, in polyadic $C_\pi$ we have 
\[
\pi \;::=\; \send\NK\role\msg{(\NL_1, \ldots, \NL_n)} \;\parop\; \receive\NK\role\msg{(\NX_1, \ldots, \NX_n)} \;\parop\; \match\NA\role\msg\NB\pi
\]
When comparing the reduction semantics of the polyadic $C_\pi$ with the reduction semantic introduced in Section~\ref{sec:Cpi-reduction-semantics}, the only difference is that now output and input involved in the reduction may have as objects tuples of channels and variables, respectively,  and that in order for reduction to take place these two tuples have to be of the same size (arity). Synchronization of actions of different arity is considered an error, known as arity mismatch (cf. the polyadic $\pi$-calculus~\cite{DBLP:conf/concur/Milner92}).
However, polyadicity in this work is more syntactic sugar, as the fragment of the polyadic $C_\pi$-calculus that we are going to use here for the purpose of the encoding of the monadic $\pi$-calculus, does not have to deal with arity mismatches and can be represent in the monadic $C_\pi$ following expected lines (we will return to this point later). 


As we noted, the (monadic) $C_\pi$-calculus differs from the (monadic) $\pi$-calculus in the restriction that input variables cannot be specified as objects of output prefixes. For instance, consider process given at the beginning of this chapter
%
\begin{equation}\label{eq:pi_process_not_Cpi_process}
\send{\mathit{chn}}\role\msg{\mathit{session}}.\mathit{Alice} \parop \receive{\mathit{chn}}\role\msg\NX.\send{\mathit{forward}}\role\msg\NX.\mathit{Bob}\parop \receive{\mathit{forward}}\role\msg\NY.\mathit{Carol}
\end{equation}
%
%
%is admissible. 
in which the leftmost thread sends $\mathit{session}$ on $\mathit{chn}$ to the thread in the middle. Then the thread in the middle forwards the received channel to the rightmost thread on $\mathit{forward}$. This $\pi$ process is clearly not a $C_\pi$ process.
%
We may try to represent the forwarding of channel $\mathit{session}$ of the middle thread in the $C_\pi$-calculus using the following idea:


\begin{itemize}
\item create a process dedicated for sending channel $\mathit{session}$, the process we call \emph{handler of channel}  $\mathit{session}$,
\item whenever channel $\mathit{session}$ is sent it is sent together with a special channel that allows to communicate with the handler, and 
\item when a process that received name $\mathit{session}$ wants to forward the name, it asks the respective handler to carry out the communication identifying on which channel $\mathit{session}$ is to be sent.
\end{itemize}  
%
Hence, our first attempt to represent the $\pi$ processes~(\ref{eq:pi_process_not_Cpi_process}) in (polyadic) $C_\pi$ is to
\begin{itemize}
\item in parallel with encoded processes from~(\ref{eq:pi_process_not_Cpi_process}) add the handler process 
\[
\handler= \receive{\mathit{handler}}\role\msg\NX.\send\NX\role\msg{(\mathit{session},\mathit{handler})}.\inact
\]
that on a special channel $\mathit{handler}$ receives a channel and then sends $\mathit{session}$ and $\mathit{handler}$ on the received channel,
\item $\mathit{Alice}$ sends channel $\mathit{session}$ together with $\mathit{handler}$, so that the receiving process ($\mathit{Bob}$) can address the handler process, i.e., $\send{\mathit{chn}}\role\msg{\mathit{session}}.\mathit{Alice}$ is represented as 
\[
A=\send{\mathit{chn}}\role\msg{(\mathit{session}, \mathit{handler})}.\mathit{Alice}'
\]
\item $\mathit{Bob}$ now receives the pair $(\mathit{session}, \mathit{handler})$ and then creates a private connection between the receiving process ($\mathit{Carol}$) with the handler process by sending to both of them a fresh channel $\mathit{private}$. Hence, $\receive{\mathit{chn}}\role\msg\NX.\send{\mathit{forward}}\role\msg\NX.\mathit{Bob}$ is represented as 
\[
B=\receive{\mathit{chn}}\role\msg{(\NX, \NM_\NX)}.\rest{\mathit{private}}\send{forward}\role\msg{\mathit{private}}.\send{\NM_\NX}\role\msg{\mathit{private}}.\mathit{Bob}'
\]
\item $\mathit{Carol}$ first receives the private channel from $\mathit{Bob}$ on channel $\mathit{forward}$ and then receives the pair $(\mathit{session}, \mathit{handler})$ from the handler process. Hence, process $\receive{\mathit{forward}}\role\msg\NY.\mathit{Carol}$ is represented as
\[
C=\receive{forward}\role\msg\NZ.\receive\NZ\role\msg{(\NY,\NM_\NY)}.\mathit{Carol}'
\]
\end{itemize} 
%

Therefore, the process in~(\ref{eq:pi_process_not_Cpi_process}) is represented with $A \parop B \parop C \parop H$. In the first reduction step of the process the pair $(\mathit{session},\mathit{handler})$ is sent from $A$ ($\mathit{Alice}$) to $B$ ($\mathit{Bob}$) leading to 
\[
\mathit{Alice}' \parop \rest{\mathit{private}}\send{forward}\role\msg{\mathit{private}}.\send{\mathit{handler}}\role\msg{\mathit{private}}.\mathit{Bob}'' \parop C \parop H
\]
where $\mathit{Bob}''=\mathit{Bob}'\subst{\mathit{session}}{\NX}\subst{\mathit{handler}}{\NM_\NX}$. Then, $\mathit{Bob}$ connects processes $C$ ($\mathit{Carol}$) and $H$ (the handler process) in two steps, leading to 
\[
\mathit{Alice}' \parop \rest{\mathit{private}}(\mathit{Bob}'' \parop \receive{\mathit{private}}\role\msg{(\NY,\NM_\NY)}.\mathit{Carol}' \parop  \send{\mathit{private}}\role\msg{(\mathit{session},\mathit{handler})}.\inact)
\]
after which $\mathit{Carol}$ can finally receive channel $\mathit{session}$ (together with channel $\mathit{handler}$) from the handler process

\[
\mathit{Alice}' \parop \rest{\mathit{private}}(\mathit{Bob}'' \parop \mathit{Carol}'' \parop  \inact)
\]
where $\mathit{Carol}''=\mathit{Carol}'\subst{\mathit{session}}{\NY}\subst{\mathit{handler}}{\NM_\NY}$. %Furthermore, we can assume here that $\mathit{private}$ is not mentioned in any of the processes, and hence we can show that the last process is structurally equivalent to 
%\[
%\mathit{Alice}' \parop \mathit{Bob}'' \parop \mathit{Carol}'' 
%\]


%
%\new{MORE DETAILS!!!!!!!}
%where the leftmost process now sends $\NL$ and also the channel $\NM_\NL$ which is to be used for communicating with the handler for channel $\NL$, the process added in parallel on the right. The forwarding thread now receives both $\NL$ and $\NM_\NL$ and the process in~(\ref{eq:pi_process_into_Cpi_process}) evolves to
%
%\begin{equation}
%\inact 
%\parop \rest\NE\send\NGG\role\msg\NE.\send{\NM_\NL}\role\msg\NE.\inact 
%\parop \receive\NGG\role\msg\NZ.\receive\NZ\role\msg\NY.\inact
%\parop \receive{\NM_\NL}\role\msg\NX.\send\NX\role\msg\NL.\inact
%\end{equation}
% 
%where $\NM_\NX$ is instantiated with the received channel $\NM_\NL$. Now, instead of forwarding, the thread creates a fresh channel and makes a private connection between the receiving process and the handler for $\NL$
%
%\begin{equation}\label{eq:pi_process_into_Cpi_process_evolution2}
%\inact 
%\parop \rest\NE(\inact 
%\parop \receive\NE\role\msg\NY.\inact
%\parop \send\NE\role\msg\NL.\inact)
%\end{equation}
%
%where finally the handler process can send $\NL$ to the receiving process.



There are two additional points we need to take care when following the idea introduced above: 
\begin{itemize}
\item forwarding a channel can be required an indefinite (possibly infinite) number of times, hence the handler must be repeatedly available to answer forwarding requests,
%in $C_\pi$, a channel can be sent infinitely many times for which handler of each channel must be 
%repeatedly available;
\item for the sake of a faithful representation of the forwarding behavior we need to ensure that forwarder and (final) receiver agree on when the forwarding has taken place since a direct synchronization ensures this. 
%the $\pi$-calculus process~(\ref{eq:pi_process_not_Cpi_process}) in one step evolves to $\inact \parop \send\NGG\role\msg\NL.\inact \parop \receive\NGG\role\msg\NY.\inact$, where the middle and the rightmost thread  synchronize on $\NGG$, while the $C_\pi$ process~(\ref{eq:pi_process_into_Cpi_process}) in two steps evolves to~(\ref{eq:pi_process_into_Cpi_process_evolution2}) where the process receiving on $\NGG$ synchronize the actions with the handler, while the process sending on $\NGG$ has already activated its continuation (here $\inact$). Therefore, without an additional mechanism for direct synchronizations, the encoding can interfere with sequentiality of actions given in threads in the source language. 
\end{itemize}
To address the last two issues, we can refine the $A \parop B \parop C \parop \handler$ representation of the process in~(\ref{eq:pi_process_not_Cpi_process}), by specifying the handler process to be replicated, i.e., 
\[
\handler= \rep\receive{\mathit{handler}}\role\msg\NX.\send\NX\role\msg{(\mathit{session},\mathit{handler})}.\inact
\]
and processes $B$ and $C$ to be
\[
B=\receive{\mathit{chn}}\role\msg{(\NX, \NM_\NX)}.\rest{\mathit{private}, \mathit{lock}}\send{forward}\role\msg{(\mathit{private}, \mathit{lock})}.\send{\NM_\NX}\role\msg{\mathit{private}}.\send{\mathit{lock}}\role\msg{}.\mathit{Bob}'
\]
and 
\[
C=\receive{forward}\role\msg{(\NZ,\NZ')}.\receive\NZ\role\msg{(\NY,\NM_\NY)}.\receive{\NZ'}\role\msg{\NZ''}.\mathit{Carol}'
\]
wherein the synchronization on channel $\mathit{forward}$ together with  channel $\mathit{private}$ another fresh channel $\mathit{lock}$ is sent from $B$ to $C$. This channel is used only after $C$ has received $(\mathit{session}, \mathit{handler})$ from the handler process, to signal that forwarding is completed and to unlock processes $\mathit{Bob}''$  and $\mathit{Carol}''$ simultaneously upon the synchronization. 


%Implementing the all above, the process given in~(\ref{eq:pi_process_into_Cpi_process}) becomes
%
%\begin{equation}\label{eq:pi_process_into_Cpi_process_final} 
%\begin{array}{@{}l@{}}
%\send\NK\role\msg{\NL}.\send\NK\role\msg{\NM_{\NL}}.\inact 
%\parop \receive\NK\role\msg{\NX}.\receive\NK\role\msg{ \NM_\NX}.\rest{\NE_1, \NE_2}\send\NGG\role\msg{\NE_1}.\send{\NE_1}\role\msg{\NE_2}.\send{\NM_\NX}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}.\inact 
%\vspace{2mm}\\
%\parop \receive\NGG\role\msg\NZ.\receive\NZ\role\msg\NY.\receive\NZ\role\msg{\NZ'}.\receive\NZ\role\msg{\NZ''}.\receive\NY\role\msg{\NY'}.\inact
%\parop \rep\receive{\NM_\NL}\role\msg\NX.\send\NX\role\msg\NL.\send\NX\role\msg{\NM_\NL}.\inact.
%\end{array}
%\end{equation}
%
%
%Furthermore, in order to represent our encoding in a more compact way will use the polyadic version of our calculus. This way, the process given in~(\ref{eq:pi_process_into_Cpi_process_final}) becomes
%
%\begin{equation}\label{eq:pi_process_into_Cpi_process_polyadic} 
%\begin{array}{@{}l@{}}
%\send\NK\role\msg{(\NL,\NM_{\NL})}.\inact 
%\parop \receive\NK\role\msg{(\NX, \NM_\NX)}.\rest{\NE_1, \NE_2}\send\NGG\role\msg{(\NE_1,\NE_2)}.\send{\NM_\NX}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}.\inact 
%\vspace{2mm}\\
%\parop \receive\NGG\role\msg{(\NZ,\NY)}.\receive\NZ\role\msg{(\NZ',\NZ'')}.\receive\NY\role\msg{\NY'}.\inact
%\parop \rep\receive{\NM_\NL}\role\msg\NX.\send\NX\role\msg{(\NL,\NM_\NL)}.\inact.
%\end{array}
%\end{equation}
%We may notice that the polyadicity here is used in a controlled way, as the only place where monadic communications can take place are the invocation of the handler on channel $\NM_\NL$ and unlocking the continuation of the output and input processes on private channel $\NE_2$, and the rest of the actions are of arity two. 
%Thus, polyadicity here is more syntactic sugar, as by considering this fragment of the polyadic $C_\pi$-calculus we do not have to deal with arity mismatches (cf. the polyadic $\pi$-calculus~\cite{DBLP:conf/concur/Milner92}).

 
\subsection{The encoding}\label{subsec:the_encoding}
This section introduces the encoding formally.
For the purpose of introducing the renaming policy, used by the encoding, we define three disjoint infinite sets $\N_\pi$, $\N_{\varphi}$ and $\N_{\mathit{res}}$, all three containing infinite number of channel and variable names, such that the union of these three sets is the set of $C_\pi$ names $\N$. Here, $\N_\pi$ is the set of all $\pi$-calculus names, $\N_{\varphi}$ is the set of names introduced by the renaming policy $\varphi$, and $\N_{\mathit{res}}$ is the set of reserved names (used by the translation function). We let $\NM_\NA, \NM_\NK, \NM_\NX, \ldots$ range over $\N_{\varphi}$, and $\NE_1, \NE_2, \NY, \NZ, \NZ', \ldots$ range over $\N_{\mathit{res}}$. Notice that, here we assume the set of $\pi$-calculus names $\N_\pi$ is strictly contained in the set of $C_\pi$ names $\N$. Such assumption is possible since $\N_\pi$ and $\N$ (and also $\N_\varphi$ and $\N_{\mathit{res}}$) are infinite countable sets.


%We now formalize the idea of the encoding given in the example above.
Formally, our encoding is a pair $(\enc{\cdot}, \varphi_{\enc{\;}})$, where $\enc{\cdot}$ is a translation function and $\varphi_{\enc{\;}}$ is a renaming policy, cf.~\cite{DBLP:journals/iandc/Gorla10}. 
The translation function is a mapping from the $\pi$-calculus, the source terms, into the $C_\pi$-calculus, the target terms. 
The translation function $\enc{\cdot}$ relies on the renaming policy $\varphi_{\enc{\;}}$, that is a function $\varphi_{\enc{\;}}: \N_\pi \to \N_\pi\times \N_\varphi$, mapping each name $\NA$ of the source language into a pair of %$C_\pi$ 
names $(\NA, \NM_\NA)$, %$\NM_\NA$ is not a name of any source term, and if 
where for two pairs $(\NA, \NM_\NA)$ and $(\NB, \NM_\NB)$ if $\NA\not=\NB$ then also $\NM_\NA\not=\NM_\NB$. 
%We also introduce a set of reserved names, that is disjoint with all names of the renaming policy. These names are also used by the translation function, and the definitions of all sets of names and functions follow the lines of~\cite{DBLP:journals/iandc/Gorla10}.




 \begin{table}
\[
\begin{array}[t]{@{}r@{\;}c@{\;}l}
%
\enc{ \rest \NK \PP} &=& 
\rest{\NK}\rest{\NM_\NK} 
(\enc{ \PP }
\parop 
\rep\receive{\NM_\NK}\role\msg\NX.\send\NX\role\msg{(\NK,\NM_\NK)}.\inact )
%
%
\vspace{2ex}\\
%
\enc{ \match{\tilde{\NC}}\role\msg{\tilde{\ND}}\send\NA\role\msg\NB.\PP }&= & 
\rest{\NE_1}\rest{\NE_2} \match{\tilde{\NC}}\role\msg{\tilde{\ND}}\send{\NA}\role\msg{(\NE_1,\NE_2)}.\send{\NM_\NB}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP } 
%
\vspace{2ex}\\
%
\enc{ \match{\tilde{\NC}}\role\msg{\tilde{\ND}}\receive\NA\role\msg\NX.\PP } &=& 
\match{\tilde{\NC}}\role\msg{\tilde{\ND}}\receive\NA\role\msg{(\NY,\NZ)}.\receive\NY\role\msg{(\NX,\NM_\NX)}.\receive{\NZ}\role\msg{\NZ'}. \enc{ \PP }
%
\vspace{2ex}\\
%
\enc{ \PP_1 \parop \PP_2 } &=& 
\enc{ \PP_1} \parop \enc{ \PP_2 }
%
\vspace{2ex}\\
%
\enc{ \rep\PP }& =& \rep \enc{ \PP }
%
\vspace{2ex}\\
%
\enc{ \inact} &=& \inact
% 
\end{array}
\]
\caption{\label{tab:Encoding} Encoding of $\pi$ processes into $C_\pi$ processes}
\end{table}



Table~\ref{tab:Encoding} introduces the translation function inductively on the source terms.
%
%
The first rule in the table translates %a process scoped with the channel 
a name restriction. 
The resulting process specifies the encoding of the original scoped process $\enc{P}$ together with the handler for the restricted channel, both scoped with the restriction for both the channel $\NK$ and associated channel name $\NM_\NK$ (via the renaming policy).
%
%The source process is encoded as scoped with the original channel name $\NK$ and the associated channel $\NM_\NK$ (via the renaming policy), and it introduces the handler process for channel $\NK$ in parallel with $\enc{\PP}$.
The handler process is repeatedly available to be invoked (on $\NM_\NK$) and it receives a channel along which  it outputs the channel $\NK$ together with the ``access point''  of the handler ($\NM_\NK$).
By sending $\NM_\NK$, we make it possible for the process that receives (see the rule for input) to be able to afterwards directly communicate with the handler for $\NK$. 



The output process is encoded as a process that creates two fresh channels $\NE_1$ and $\NE_2$, then both channels are sent to the receiving process, on the same name $\NA$ as in the original process. Then, $\NE_1$ is also sent to the handler of name $\NB$, thus allowing to create a private connection between the receiving and handler process. Here, we use $\match{\tilde{\NC}}\role\msg{\tilde{\ND}}\pi$ to abbreviate $\match{{\NC_1}}\role\msg{{\ND_1}}\ldots\match{{\NC_n}}\role\msg{{\ND_n}}\pi$ or $\pi$ when the sequence of matchings is empty. Channel $\NE_2$ is used only in the synchronization mechanism to ensure that both continuations of the sending and the receiving processes are activated only after the forwarding mechanism is completed, so as to mimic the original behavior (cf. channel $\mathit{lock}$ in the example above).
%as the output on $\NE_2$ get triggered in synchronization with the receiving process. 
We remark that here names $\NE_1$ and $\NE_2$ are taken to be from the reserved set of names $\N_{\mathit{res}}$, and hence cannot appear as free in  $\enc\PP$. 
The same assumption is made for names $\NY, \NZ$ and $\NZ'$ in the rule for input, hence these names cannot appear as free in the continuation $\enc\PP$. 

The input process is encoded as a reception of a pair of channels (cf. the encoding of the output prefixed process). 
When a pair of names $(\NE_1, \NE_2)$ is received (from an output process) then the encoding of the input process proceeds by receiving a pair of names (from a handler process), that are then substituted in the continuation process. After that, a channel is received on channel $\NE_2$.
%On the left received channel again a pair is received, but now the received channels, which are a channel and the address of the handler of that channel, are substituted in the encoding of the continuation process $\PQ$. 
The last reception is used only for activating the continuations of the output and the input processes (as mentioned above).
The encoding is a homomorphism elsewhere. %, e.g., 

We may now notice that for the purpose of encoding monadic $\pi$-calculus in $C_\pi$, the polyadicity is used in a controlled way, as the only place where monadic communications can take place are the invocation of the handler on channel $\NM_\NL$ (from set $\N_\varphi$) and unlocking the continuation of the output and input processes on private channel $\NE_2$, and the rest of the actions are of arity two. Furthermore, all the actions of arity two are either conducted on a private channel or carrying private channel(s) as a message. This implies that we can represent the behavior of each of the polyadic prefixes by monadic ones straightforwardly. For example, $\send\NA\role\msg{(\NE_1, \NE_2)}$ in the output process can be represented by $\send\NA\role\msg{\NE_1}.\send{\NE_1}\role\msg{\NE_2}$, as channel $\NE_1$ first sent is fresh, and, hence, $\receive\NA\role\msg{(\NY, \NZ)}$ in the input process can be represented by  $\receive\NA\role\msg{\NY}.\receive\NY\role\msg\NZ$.






%%%%%%%%%%%%%%%%%%%%%%%%%%%RESULTS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\begin{lemma}\label{lem:encode-weak-stenght-sigma}
%If $\NA\notin\fn\PP$ then $\encode{\PP}{\sigma, \{\NA\to (\NN, \NM)\}}= \encode{\PP}{\sigma}$.
%\end{lemma}

%\begin{proof}
%The proof is by induction on the structure of process $\PP$. We detail only two cases.
%\begin{itemize}
%\item $\PP= \inact$.
%
%\[
%\encode{\inact}{\sigma, \{\NA\to (\NN, \NM)\}}= \inact = \encode{\inact}{\sigma}.
%\]
%
%\item $\PP= \receive\NB\role\msg\NX.\PP_1$.

%Since $\NB\in\fn\PP$, we conclude $\NA\not=\NB$, and 
%
%\[
%\encode{\receive\NB\role\msg\NX.\PP_1}{\sigma, \{\NA\to (\NN, \NM)\}}=
%\receive\NB\role\msg{(\NX, \NX_1, \NX_2, \NX_3)}.\receive{\NX_3}\role\msg\NY.\encode{\PP_1}{\sigma, \{\NA\to (\NN, \NM)\}, \{\NX\to (\NX_1, \NX_2)\}},
%\]
%
%where $\NX\not=\NA$.
%By induction hypothesis $\encode{\PP_1}{\sigma, \{\NA\to (\NN, \NM)\}, \{\NX\to (\NX_1, \NX_2)\}}= \encode{\PP_1}{\sigma, \{\NX\to (\NX_1, \NX_2)\}}$, and applying the encoding definition again we get 
%
%\[
%\encode{\receive\NB\role\msg\NX.\PP_1}{\sigma, \{\NA\to (\NN, \NM)\}}=\encode{\receive\NB\role\msg\NX.\PP_1}{\sigma}.
%\]
%
%\end{itemize}
%\end{proof}
%
%
\subsection{Operational correspondence}\label{subsec:Cpi_operational_correspondence}

Our operational correspondence result relates the sum-free $\pi$-calculus and the $C_\pi$-calculus, relying on the respective reduction semantics. 
Actually, the reduction semantics of the $C_\pi$-calculus, presented in Section~\ref{sec:Cpi-reduction-semantics}, uses the same set of rules as the reduction semantics given in~\cite{pi_calculus}, restricted here only with the syntax of $C_\pi$.
Hence, we will use $\equiv$, $\red$ and $\simeq$ to denote structural congruence, reduction, and strong barbed equivalence relation, respectively, for both $\pi$ and $C_\pi$, contextualized whenever required to clarify to which of these languages they belong. We also use $\redd$ to denote the transitive closure of $\red$. 

The encoding (Table~\ref{tab:Encoding}) does not introduce any free names, except in the rule for output, where name $\NM_\NB$ is introduced. This name is also the one specified in the renaming policy of name $\NB$. Hence, assuming that substitutions on pairs of names introduced by the renaming policy are defined component-wise: the first components are mapped to $\N_\pi$, and the second components are mapped to $\N_\varphi$, we have the following result. % is straightforward.

\begin{lemma}[Name invariance] Let $\PP$ be a $\pi$ process and let substitutions $\sigma$ and $\sigma'$ be such that $\varphi_{\enc{\;}}(\sigma(\NA))=\sigma'(\varphi_{\enc{\;}}(\NA))$, for all $\NA\in\N_\pi$.
Then $\enc{(\PP)\sigma}=(\enc{\PP})\sigma'$.
\end{lemma}
\begin{proof}
The proof is by induction on the structure of process $\PP$. We detail only the case when $\PP=\send\NA\role\msg\NL.\PP_1$. 
Assume $\sigma(\NA)=\NB$ and $\sigma(\NL)=\NM$. If $\varphi_{\enc{\;}}(\NA)=(\NA, \NM_\NA)$ and $\varphi_{\enc{\;}}(\NB)=(\NB, \NM_\NB)$ then from $\varphi_{\enc{\;}}(\sigma(\NA))=\sigma'(\varphi_{\enc{\;}}(\NA))$ we conclude $\sigma'(\NA, \NM_\NA)=(\NB, \NM_\NB)$. Likewise, if $\varphi_{\enc{\;}}(\NL)=(\NL, \NM_\NL)$ and $\varphi_{\enc{\;}}(\NK)=(\NK, \NM_\NK)$ we have $\sigma'(\NL, \NM_\NL)=(\NK, \NM_\NK)$. Then,
\[
\begin{array}{l@{\;}c@{\;}l}
\enc{(\send\NA\role\msg\NL.\PP_1)\sigma} 
& = & \enc{\send\NB\role\msg\NK.(\PP_1\sigma)}\\
& = & \rest{\NE_1,\NE_2} \send{\NB}\role\msg{(\NE_1,\NE_2)}.\send{\NM_\NK}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}. \enc{ (\PP_1\sigma) } \\
& = & \rest{\NE_1,\NE_2} \send{\NB}\role\msg{(\NE_1,\NE_2)}.\send{\NM_\NK}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}. (\enc{ \PP_1 })\sigma'\\
& = & (\rest{\NE_1,\NE_2} \send{\NA}\role\msg{(\NE_1,\NE_2)}.\send{\NM_\NL}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}. \enc{ \PP_1 })\sigma'\\
& = & (\enc{\send\NA\role\msg\NL.\PP_1})\sigma'
\end{array}
\]
by the definition of the encoding, and where $\enc{ (\PP_1\sigma) }=(\enc{ \PP_1 })\sigma'$ holds by induction hypothesis.
\end{proof}


For the operational correspondence, we need only one case of the name invariance result, and we state it in the next corollary.

\begin{corollary}[Encoding and substitution]\label{lem:encode-subst}
Let $\PP$ be a $\pi$ process and $\NK,\NX\in\N_\pi$ such that $\varphi_{\enc{\;}}(\NK)=(\NK, \NM_\NK)$ and $\varphi_{\enc{\;}}(\NX)=(\NX, \NM_\NX)$. Then 
\[
\enc{\PP}\subst{\NK}{\NX}\subst{\NM_\NK}{\NM_\NX}= \enc{\PP\subst{\NK}{\NX}}.%{\sigma}.
\]
\end{corollary}

%\begin{proof}
%The proof is by induction on the structure of $\PP$. We detail only the case of output prefixed process. 

%Let $\PP=\send\NX\role\msg\NX.\PP_1$. Then, since $\varphi_{\enc{\;}}(\NX)=(\NN_\NX, \NM_\NX)$, we have 
%\[
%\enc{\send\NX\role\msg\NX.\PP_1}= \rest{\NE_1, \NE_2}\send{\NN_\NX}\role\msg{\NE_1}.\send{\NM_\NX}\role\msg{(\NE_1, \NE_2)}.\receive{\NE_2}\role\msg\NY.\send\NY\role\msg{\NE_1}. \enc{\PP_1}.
%\]
%By induction hypothesis 
%\[
%\enc{\PP_1}\subst{\NK}{\NX}\subst{\NN_\NK}{\NN_\NX}\subst{\NM_\NK}{\NM_\NX}= \enc{\PP_1\subst{\NK}{\NX}}.%{\sigma}.
%\]
%Hence
%\[
%\enc{\send\NX\role\msg\NX.\PP_1}\subst{\NK}{\NX}\subst{\NN_\NK}{\NN_\NX}\subst{\NM_\NK}{\NM_\NX}=  \rest{\NE_1, \NE_2}\send{\NN_\NK}\role\msg{\NE_1}.\send{\NM_\NK}\role\msg{(\NE_1, \NE_2)}.\receive{\NE_2}\role\msg\NY.\send\NY\role\msg{\NE_1}. \enc{\PP_1\subst{\NK}{\NX}},
%\]
%and by the encoding definition we conclude 
%\[
%\enc{\send\NX\role\msg\NX.\PP_1}\subst{\NK}{\NX}\subst{\NN_\NK}{\NN_\NX}\subst{\NM_\NK}{\NM_\NX}= \enc{\send\NK\role\msg\NK.\PP_1\subst{\NK}{\NX}}.
%\]
%\end{proof}

To simplify notation we use the following abbreviations: $\rest{\tilde{\NK}}\PP$ stands for $\rest{\NK_1}\ldots\rest{\NK_n}\PP$ or $\PP$ (when $\tilde{\NK}$ is an empty list), and $\handler_\NL$ stands for the handler process $\rep\receive{\NM_\NL}\role\msg\NX.\send\NX\role\msg{(\NL,\NM_\NL)}.\inact$, where $\varphi_{\enc{\;}}(\NL)=(\NL, \NM_\NL)$. 
We also use $\rest{\NK,\NM_\NK}\PP$ to abbreviate $\rest\NK\rest{\NM_\NK}\PP$, and $\rest{\tilde{\NK}, \tilde{\NM}_\NK}\PP$ to abbreviate $\rest{\NK_1,\NM_{\NK_1}}, \ldots, \rest{\NK_n, \NM_{\NK_n}}\PP$ or $\PP$, where $\varphi_{\enc{\;}}(\NK_i)=(\NK_i, \NM_{\NK_i})$. Furthermore, whenever we write name $\NM_\NA$ from $\N_\varphi$ we assume that $\varphi_{\enc{\;}}(\NA)=(\NA, \NM_\NA)$, for $\NA\in\N_\pi$.

In order to show that our encoding preserves the structural congruence relation, up to strong barbed equivalence, 
we present an auxiliary result showing that a restricted handler process is behaviorally equivalent to the inactive process.


\begin{proposition}[Restricted handlers]\label{prop:rest_handler_bisimilar_to_0}
For any channel name $\NK\in\N_\pi$ we have that $\rest{\NM_\NK}\handler_\NK\simeq\inact$.
\end{proposition}
\begin{proof}
The proof is direct. We show that the two processes are bisimilar, by noticing that the only possible action of the process
\[\rest{\NM_\NK}\handler_\NK= \rest{\NM_\NK}\rep\receive{\NM_\NK}\role\msg{\NX}.\send{\NX}\role\msg{(\NK,\NM_\NK)}.\inact
\]
is an input on $\NM_\NK$ that is blocked due to side condition of rule \rulename{(res)} since the subject of the action is restricted. Hence, the process is strongly bisimilar with an inactive process. Then, by Theorem~\ref{th:strong_characterization} (which states $\sim \;=\; \simeq$) we conclude the proof.
\end{proof}

The next lemma shows that the encodings of two structurally equivalent processes yield two processes related by the strong barbed equivalence relation. Here we use structural congruence relation of (sum-free) $\pi$ processes as defined in~\cite{pi_calculus}, which matches the rules given in Section~\ref{sec:Cpi-reduction-semantics}.

\begin{lemma}[Encoding and structural congruence]\label{lem:encode-struct-to-bisim}
If $\PP$ and $\PQ$ are $\pi$ processes such that $\PP\equiv\PQ$  then $\enc{\PP} \simeq \enc{\PQ}$.
\end{lemma}
%
\begin{proof}
The proof is by induction on the derivation $\PP\equiv$. We perform the case analysis on the last rule applied. In all cases, except the case $2$., we may directly show that if $\PP\equiv\PQ$ then $\enc{\PP} \equiv \enc{\PQ}$, and then to conclude by Proposition~\ref{prop:Cpi-bisim-standard-props} ($\equiv\;\subseteq \sim$) and Theorem~\ref{th:strong_characterization} ($\sim \;=\; \simeq$).
\begin{enumerate}
\item $\match\NA\role\msg\NA\pi.\PP \equiv \pi.\PP$.

We distinguish two cases for prefix $\pi$. 
	\begin{enumerate}
	\item If $\pi=\match{\tilde{\NB}}\role\msg{\tilde{\NC}}\receive\ND\role\msg\NX$,
	then by definition of the encoding and definition of the structural congruence (Table~\ref{tab:Cpi-structural}) relation we have that 
	\[
	\begin{array}{l@{\;}c@{\;}l}
	\enc{\match\NA\role\msg\NA\pi.\PP} 
	& = &
	\match\NA\role\msg\NA\match{\tilde{\NB}}\role\msg{\tilde{\NC}}
	\receive\ND\role\msg{(\NY,\NZ)}.\receive\NY\role\msg{(\NX,\NM_\NX)}.\receive{\NZ}\role\msg{\NZ'}.\enc{\PP} \\
	&\equiv &
	\match{\tilde{\NB}}\role\msg{\tilde{\NC}}
	\receive\ND\role\msg{(\NY,\NZ)}.\receive\NY\role\msg{(\NX,\NM_\NX)}.\receive{\NZ}\role\msg{\NZ'}.\enc{\PP} \\
	& = & 
	\enc{\pi.\PP}.
	\end{array}
	\]

	\item If $\pi=\match{\NB_1}\role\msg{\NC_1}...\match{\NB_n}\role\msg{\NC_n}\send\ND\role\msg\NGG$,
	then, since $\equiv$ is a congruence, hence preserved also by channel restriction construct, we may show 

	\[
	\begin{array}{l@{\;}c@{\;}l}
	\hspace{-8mm}\enc{\match\NA\role\msg\NA\pi.\PP} 
	& = &  \rest{\NE_1, \NE_2}\match\NA\role\msg\NA\match{\tilde{\NB}}\role\msg{\tilde{\NC}}\send{\ND}\role\msg{(\NE_1,\NE_2)}.\send{\NM_\NGG}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}. \enc{ \PP } \\
	& \equiv &  \rest{\NE_1, \NE_2}\match{\tilde{\NB}}\role\msg{\tilde{\NC}}\send{\ND}\role\msg{(\NE_1,\NE_2)}.\send{\NM_\NGG}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}. \enc{ \PP }\\
	& = & 
	\enc{\pi.\PP}.
	\end{array}
	\]
	%where $\sigma(\ND)=(\NN_1, \NM_1)$ and $\sigma(\NGG)=(\NN_2, \NM_2)$.
	\end{enumerate}

\item $\rest\NK\inact \equiv \inact$. By the definition of the encoding and structural congruence, and by Proposition~\ref{prop:rest_handler_bisimilar_to_0} we observe
\[
\enc{\rest\NK\inact}  = 
\rest{\NK,  \NM_\NK}(\inact \parop \handler_\NK) 
 \equiv  \rest{\NK, \NM_\NK}\handler_\NK 
\simeq  \inact= \enc{\inact}.
\]

\item The rest of the cases are analogous.
\end{enumerate}
\end{proof}
%


%
We may present the first main result that attests the correctness of our translation, which says that if the source process $\PP$ reduces to $\PQ$ then the encoding of $\PP$ also reduces, in a number of steps, to the encoding of process $\PQ$. Since in the reductions of a source process free names can be exchanged, our result uses ``top-level'' handlers for all free names specified as objects of the output prefixes of the process. 
In what follows, we use $\prod\limits_{i\in I} \PP_i$ to abbreviate $\PP_1 \parop \ldots \parop \PP_n$ when $I=\{1, \ldots, n\}$, and $\inact$ when $I=\emptyset$.


\begin{lemma}[Completeness with top-level handlers]\label{lem:oper-corresp-with-Hs-completeness}
If $\PP$ and $\PQ$ are $\pi$ processes such that  $\PP \red \PQ$ then 
\[
\enc{\PP}\parop \handler \redd \simeq \enc{\PQ}\parop \handler
\]
where 
$\handler=\prod\limits_{\NN\in N} \handler_{\NN}$, for any finite $N\subset\N_\pi$, such that $\fo\PP\subseteq N.$
\end{lemma}
%
\begin{proof}
The proof is by induction on $\PP\red\PQ$ derivation.
\begin{enumerate}
\item \emph{Base case}: $\send\NK\role\msg\NL.\PP \parop \receive\NK\role\msg\NX.\PQ \red \PP \parop \PQ\subst{\NL}{\NX}$. Since $\NL$ is a free object of the prefix in the starting process, we need to show that 
\[
\enc{\send\NK\role\msg\NL.\PP \parop \receive\NK\role\msg\NX.\PQ} \parop \handler \redd \simeq \enc{\PP \parop \PQ\subst{\NL}{\NX}} \parop \handler 
\]
where $\handler\equiv\handler_\NL \parop\handler_1$, for some $\handler_1$.
If we denote $\PR=\enc{\send\NK\role\msg\NL.\PP \parop \receive\NK\role\msg\NX.\PQ}\parop  \handler_\NL \parop\handler_1$, we have  
\[
\begin{array}{l@{\,}c@{\,}l}
\PR 
& = & 
\rest{\NE_1,\NE_2} \send{\NK}\role\msg{(\NE_1,\NE_2)}.\send{\NM_\NL}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP }
\parop \receive\NK\role\msg{(\NY,\NZ)}.\receive\NY\role\msg{(\NX,\NM_\NX)}.\receive{\NZ}\role\msg{\NZ'}. \enc{\PQ} \\
%
& & \parop \rep\receive{\NM_\NL}\role\msg{\NX}.\send{\NX}\role\msg{(\NL,\NM_\NL)}.\inact  \parop \handler_1  \\
%
& \red\red & 
\rest{\NE_1,\NE_2} (\send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP }
\parop \receive{\NE_1}\role\msg{(\NX,\NM_\NX)}.\receive{\NE_2}\role\msg{\NZ'}. \enc{\PQ} 
 \parop \send{\NE_1}\role\msg{(\NL,\NM_\NL)}.\inact ) \parop \handler_\NL \parop \handler_1 \\
%
%
\end{array}
\]
%
where the output process first synchronizes with the receiving process, sending fresh channels $\NE_1$ and $\NE_2$, and then, with the handler of channel $\NL$, by sending $\NE_1$, and, thus creates a private connection between the receiving process and the handler. 
At this point, the handler can synchronize with the receiving process
%
\[
\rest{\NE_1,\NE_2} (\send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP }
\parop \receive{\NE_1}\role\msg{(\NX,\NM_\NX)}.\receive{\NE_2}\role\msg{\NZ'}. \enc{\PQ} 
\parop \send{\NE_1}\role\msg{(\NL,\NM_\NL)}.\inact ) \parop \handler_\NL \parop \handler_1 \red 
\]
\[ 
\rest{\NE_1,\NE_2} (\send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP }
\parop \receive{\NE_2}\role\msg{\NZ'}. \enc{\PQ}\subst{\NL}{\NX}\subst{\NM_\NL}{\NM_\NX} \parop \inact) \parop \handler_\NL  \parop \handler_1 
\]
%
where channels $\NL$ and $\NM_\NL$  
are finally received in the input process. The encoding of  processes $\PP$ and $\PQ$ is only unlocked in the synchronization on private channel $\NE_2$, and since $\NE_1$ and $\NE_2$ are from the reserved set of names, hence not free in $\enc{ \PP }\parop  \enc{\PQ}\subst{\NL}{\NX}\subst{\NM_\NL}{\NM_\NX}$, the last derived process can reduce
%
\[ 
\rest{\NE_1,\NE_2} (\send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP }
\parop \receive{\NE_2}\role\msg{\NZ'}. \enc{\PQ}\subst{\NL}{\NX}\subst{\NM_\NL}{\NM_\NX} \parop \inact) \parop \handler_\NL  \parop \handler_1 \red
\]
\[  
 \enc{ \PP }
\parop  \enc{\PQ}\subst{\NL}{\NX}\subst{\NM_\NL}{\NM_\NX}   \parop \handler_\NL  \parop \handler_1  
\]
%
By Corollary~\ref{lem:encode-subst} we have $
\enc{\PQ}\subst{\NL}{\NX}\subst{\NM_\NL}{\NM_\NX}=
\enc{\PQ\subst{\NL}{\NX}}.
$ 
%and by Lemma~\ref{lem:encode-weak-stenght-sigma}  we get
%$\encode{\PQ\subst{\NB}{\NX}}{\sigma, \{\NX\to(\NX_1, \NX_2)\}}=
%\encode{\PQ\subst{\NB}{\NX}}{\sigma}$. 
Hence, we have that
\[
 \enc{ \PP }
\parop  \enc{\PQ}\subst{\NL}{\NX}\subst{\NM_\NL}{\NM_\NX}   \parop \handler_\NL  \parop \handler_1 \equiv 
\enc{\PP \parop \PQ\subst{\NL}{\NX}} \parop \handler
\]
and we may conclude by Proposition~\ref{prop:Cpi-bisim-standard-props} ($\equiv\;\subseteq\; \sim$) and Theorem~\ref{th:strong_characterization} ($\sim\; = \; \simeq$).
%
%
\item \emph{Case}: $\PP \parop \PR \red \PQ \parop \PR$ is derived from $\PP\red\PQ$. 
By induction hypothesis  %and $\sigma_1(\NC_i)=(\NN_i, \NM_i)$, for $i=1, \ldots, k$ 
 
\[
\enc{\PP}\parop \handler_1 \redd \simeq \enc{\PQ}\parop \handler_1
\]
where  
$\handler_1=\prod\limits_{\NN\in N} \handler_{\NN}$, for any finite $N\subset \N_\pi$, such that $\fo\PP\subseteq N$.
Now, 
%Let us define a mapping $\sigma$ with domain set $\fn{\PP \parop \PR}$ such that 
%$\sigma(\NA)=\sigma_1(\NA)$ if $\NA\in\fn{\PP}$ and $\sigma_1(\ND_j)=(\NN_j', \NM_j')$, for $j=1, \ldots, l$, where names $\NN_i, \NM_i, \NN_j', \NM_j'$ are pairwise distinct and disjoint with $\fn{\PP \parop \PR}$
let us take 
$\handler_2=\prod\limits_{\NN\in\fo{\PR}\setminus N} \handler_{\NN}$.

Since $\enc{\PP \parop \PR} \parop \handler_1\parop \handler_2 
\equiv
\enc{\PP}\parop \handler_1 \parop \enc{\PR} \parop \handler_2$ and $\enc{\PQ}  \parop \handler_1  \parop \enc{\PR}  \parop \handler_2 \equiv \enc{\PQ \parop \PR}\parop \handler_1\parop \handler_2$, by \rulename{(r-par)} and \rulename{(r-stru)} we can derive 
\[
\enc{\PP \parop \PR} \parop \handler_1\parop \handler_2  
\redd \simeq
\enc{\PQ \parop \PR}\parop \handler_1\parop \handler_2
\]
where $\handler_1\parop \handler_2=\prod\limits_{\NN\in N'} \handler_{\NN}$, for any finite $N'\subset\N_\pi$, such that $\fo{\PP\parop\PR}\subseteq N'$.
%
%
\item \emph{Case}: $\rest\NK \PP \red \rest\NK \PQ$ is derived from $\PP\red\PQ$. Again, by induction hypothesis %and $\sigma_1(\NC_i)=(\NN_i, \NM_i)$, for $i=1, \ldots, k$  
\[
\enc{\PP}\parop \handler_1 \redd \simeq\enc{\PQ}\parop \handler_1
\]
where  
$\handler_1=\prod\limits_{\NN\in N} \handler_{\NN}$, for any finite $N\subset \N_\pi$, such that $\fo\PP\subseteq N$.
We now distinguish two cases.
	\begin{enumerate}
	\item If $\NK\in\fo{\PP}$ then %$\sigma_2=\sigma_1$ and 
	$\handler_1\equiv\handler_\NK\parop \handler$, for some $\handler$.
	Then, by \rulename{(r-res)} we can derive 
	\[
	\rest{\NK,\NM_\NK}(\enc{\PP}\parop \handler_\NK\parop \handler ) \redd \simeq \rest{\NK, \NM_\NK}(\enc{\PQ}\parop \handler_\NK\parop \handler) 
	\]
	Since $\NK,\NM_\NK\notin\fn{\handler}$, we have 
	\[
	\rest{\NK,\NM_\NK}(\enc{\PP}\parop \handler_\NK\parop \handler )\equiv\rest{\NK,\NM_\NK}(\enc{\PP}\parop \handler_\NK)\parop \handler=\enc{\rest\NK\PP}\parop \handler
	\] 
	Similarly, $\rest{\NK, \NM_\NK}(\enc{\PQ}\parop \handler_\NK\parop \handler) \equiv \enc{\rest\NK\PQ}\parop \handler$, and by $\fo{\rest\NK\PP}=\fo{\PP}\setminus\{\NK\}$, we can conclude the case.
	%
	\item If $\NK\notin\fo{\PP}$ then by \rulename{(r-par)} and \rulename{(r-res)} we can derive 
	\[
	\rest{\NK,\NM_\NK}(\enc{\PP}\parop \handler_1 \parop \handler_\NK) \redd\simeq \rest{\NK, \NM_\NK}(\enc{\PQ}\parop \handler_1 \parop \handler_\NK)
	\]
	Since now $\NK,\NM_\NK\notin\fn{\handler_1}$, similarly as in the previous case we can show 
	$\rest{\NK,\NM_\NK}(\enc{\PP}\parop \handler_1 \parop \handler_\NK) \equiv \enc{\rest\NK\PP}\parop \handler_1$ and $\rest{\NK, \NM_\NK}(\enc{\PQ}\parop \handler_1 \parop \handler_\NK)\equiv \enc{\rest\NK\PQ} \parop \handler_1$. 
	Then, by $\fo{\rest\NK\PP}=\fo{\PP}$, we can conclude.
	\end{enumerate}
\item \emph{Case}: $\PP'\red\PQ'$ is derived from $\PP\red\PQ$, where $\PP\equiv\PP'$ and $\PQ\equiv\PQ'$. 
By induction hypothesis%,  and $\sigma(\NC_i)=(\NN_i, \NM_i)$, for $i=1, \ldots, k$ then 
\[
\enc{\PP}\parop \handler_1 \redd \simeq \enc{\PQ}\parop \handler_1
\]
where  
$\handler_1=\prod\limits_{\NN\in N} \handler_{\NN}$, for any finite $N\subset \N_\pi$, such that $\fo\PP\subseteq N$.
By Lemma~\ref{lem:encode-struct-to-bisim}, $\PP\equiv\PP'$ implies 
$\enc{\PP}\simeq\enc{\PP'}$ and $\PQ\equiv\PQ'$ implies $\enc{\PQ}\simeq\enc{\PQ'}$. Also, since $\PP\equiv\PP'$, by Lemma~\ref{lem:fo_in_equiv_and_red} we have $\fo\PP=\fo{\PP'}$.
Then, by Proposition~\ref{prop:Cpi_bisim_congruence} and Theorem~\ref{th:strong_characterization} we get 
$\enc{\PP}\parop\handler_1 \simeq \enc{\PP'}\parop \handler_1$. 
Hence, 
by definition of strong barbed equivalence 
\[
\enc{\PP'}\parop \handler_1 \redd \simeq  \enc{\PQ}\parop \handler_1 \simeq \enc{\PQ'}\parop \handler_1
\] 
which completes the proof.
\end{enumerate}
\end{proof}

Notice that the condition $\PP\red\PQ$ in the previous lemma can be generalized to the case of a sequence of reductions of the source term (i.e., $\PP\redd\;\PQ$). This is for the arrival state ($\PQ$) also satisfies the lemma conditions, as by Lemma~\ref{lem:fo_in_equiv_and_red} from $\PP\red\PQ$ we may conclude $\fo\PQ\subseteq\fo\PP$. 
As a direct consequence of Lemma~\ref{lem:oper-corresp-with-Hs-completeness}, we get the operational correspondence result for the encoding of $\pi$-calculus processes having no free object names.

\begin{corollary}[Operational correspondence: completeness]\label{theorem:operational-corresp}
Let $\PP$ be a (sum-free) $\pi$ process such that $\fo\PP=\emptyset$. 
If $\PP\red\PQ$ then $\enc{\PP}\redd \simeq\enc{\PQ}$. %, for any mapping $\sigma$.
\end{corollary}




We now proceed to show that our encoding also satisfies the soundness property (cf.~\cite{DBLP:journals/iandc/Gorla10}). 
To this end, we define the static contexts in order to determine the active prefixes of a $C_\pi$ process. Intuitively, an (active) context is a process with a (non-prefixed) ``hole'', in which processes can be instantiated. 
%The rest of the section deals with general $\pi$-calculus processes, and all the properties given here are inherited in $C_\pi$.

\begin{definition}[Active contexts]\label{def:active_contexts}
 Active contexts for $C_\pi$ processes are defined as follows.
\[
\context[\cdot]::= \quad\cdot \quad\parop\quad (\PP\parop\context[\cdot]) \quad\parop\quad (\context[\cdot]\parop\PP) \quad\parop\quad (\rest\NK\context[\cdot]) \quad\parop\quad \rep\context[\cdot]
\]
\end{definition}

Hence, prefix $\pi$ inside process $\PP$ is active only if there exists a context $\context[\cdot]$ and process $\PP'$ such that $\PP=\context[\pi.\PP']$.
Notice that, by the definition of the encoding, only prefixes of the source terms reproduce sequences of prefixes in the target term, except the prefixes introduced by the handlers. However, active prefixes of the handlers are different from others in a target term, as they are all inputs with subject names introduced by the renaming policy (i.e., from $\N_\varphi$), while the subjects of other prefixes are the ones given in the source term (i.e., from $\N_\pi$). Hence, the handlers cannot be engaged in the reduction directly in the target term but can be engaged only in latter reductions.
The next lemma shows that all active prefixes of any target term can be singled out using the structural congruence relation and that the target term can be directly related to the corresponding source term. Here we focus on the active prefixes of the target terms that can be engaged in a reduction, hence not the ones given in the handler processes.



\begin{lemma}[Normal form of target and source terms]\label{lem:shape_of_encoded_processes}
Let $\PP$ be a $\pi$ process.  We have that
\[
\begin{array}{c@{\,}c@{\,}l}
\enc{\PP}
& \equiv & \rest{\tilde{\NK},\tilde{\NM}_\NK}(\prod\limits_{i\in I} \enc{\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep\enc{\PR_j} \parop \handler) \quad  \text{ and }\\
\PP 
& \equiv & \rest{\tilde{\NK}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \prod\limits_{j\in J}\rep\PR_j )
\end{array}
\]
where $\handler=\prod\limits_{\NK\in\tilde{\NK}}\handler_\NK$, 
and if $\enc{\PP}=\context[\enc{\pi.\PQ}]$ then there is some $i\in I$ such that $\pi.\PQ=\pi_i.\PP_i$.
\end{lemma}
\begin{proof}
The proof is by induction on the structure of process $\PP$.
\begin{enumerate}
\item  \emph{Case}: If $\PP=\inact$ or $\PP=\pi.\PP_1$, the proof follows directly.
\item  \emph{Case}: $\PP=\PP_1 \parop \PP_2$. By induction hypothesis we have 
\[
\begin{array}{c@{\,}c@{\,}l}
\enc{\PP_l}
& \equiv & \rest{\tilde{\NK}_l,\tilde{\NM}_{\NK_l}}(\prod\limits_{i\in I_l} \enc{\pi_i.\PP_i} \parop \prod\limits_{j\in J_l} \rep\enc{\PR_j} \parop \handler^l) \quad  \text{ and }\\
\PP _l
& \equiv & \rest{\tilde{\NK}_l}(\prod\limits_{i\in I_l} \pi_i.\PP_i \parop \prod\limits_{j\in J_l}\rep\PR_j )
\end{array}
\]
where $\handler^l=\prod\limits_{\NK\in\tilde{\NK}_l}\handler_\NK$, and if $\enc{\PP_l}= \context[\enc{\pi.\PQ}]$ then there is $i\in I_l$ such that $\pi.\PQ=\pi_i.\PP_i$,  for $l$ in $\{1,2\}$.
Without loss of generality we assume the chosen sets of labels $I_1, I_2, J_1$ and $J_2$ are pair-wise disjoint. Hence,
\[
\begin{array}{@{}c@{\;}c@{\;}l@{}}
\enc{\PP}
& = & \enc{\PP_1} \parop \enc{\PP_2}\\ 
& \equiv & 
\rest{\tilde{\NK}_1,\tilde{\NM}_{\NK_1}}\rest{\tilde{\NK}_2,\tilde{\NM}_{\NK_2}}
(\prod\limits_{i\in I_1\cup I_2} \enc{\pi_i.\PP_i} \parop \prod\limits_{j\in J_1\cup J_2} \rep\enc{\PR_j} \parop \handler^1 \parop \handler^2) \quad  \text{ and }\\
\PP
& = & \PP_1 \parop \PP_2\\ 
& \equiv & 
\rest{\tilde{\NK}_1}\rest{\tilde{\NK}_2}
(\prod\limits_{i\in I_1\cup I_2} \pi_i.\PP_i \parop \prod\limits_{j\in J_1\cup J_2} \rep\PR_j )
\end{array}
\]
%since without loss of generality we can assume $\tilde{\NN}_1\cap \fn{\PP_2}=\emptyset$ and $\tilde{\NN}_2\cap \fn{\PP_1}=\emptyset$. 
Since the active prefixes of $\enc{\PP}$ are the ones of the $\enc{\PP_1}$ and $\enc{\PP_2}$, we may conclude the case.
\item \emph{Case}: $\PP=\rest{\NK}\PP_1$. By induction hypothesis we have 
\[
\begin{array}{c@{\,}c@{\,}l}
\enc{\PP_1}
& \equiv & \rest{\tilde{\NK},\tilde{\NM}_\NK}(\prod\limits_{i\in I} \enc{\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep\enc{\PR_j} \parop \handler) \quad  \text{ and }\\
\PP_1
& \equiv & \rest{\tilde{\NK}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \prod\limits_{j\in J}\rep\PR_j )
\end{array}
\]
where $\handler=\prod\limits_{\NK\in\tilde{\NK}}\handler_\NK$, 
and if $\enc{\PP_1}=\context[\enc{\pi.\PQ}]$ then there is some $i\in I$ such that $\pi.\PQ=\pi_i.\PP_i$. 
Since $\enc{\PP}=\rest{\NK, \NM_\NK}(\PP_1 \parop \handler_\NK)$ and $\equiv$ is a congruence, we have that 
\[
\begin{array}{c@{\,}c@{\,}l}
\enc{\PP}
& \equiv & \rest{\NK,\NM_\NK} \rest{\tilde{\NK},\tilde{\NM}_\NK}(\prod\limits_{i\in I} \enc{\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep\enc{\PR_j} \parop \handler \parop \handler_\NK) \quad  \text{ and }\\
\PP
& \equiv & \rest\NK\rest{\tilde{\NK}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \prod\limits_{j\in J}\rep\PR_j )
\end{array}
\]
Since the active prefixes of $\enc{\PP}$ that are images of the source active prefixes are the ones of the $\enc{\PP_1}$ we may conclude the case.
\item \emph{Case}: $\PP=\rep\PP_1$. Again, by induction hypothesis 
\[
\begin{array}{c@{\,}c@{\,}l}
\enc{\PP_1}
& \equiv & \rest{\tilde{\NK},\tilde{\NM}_\NK}(\prod\limits_{i\in I} \enc{\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep\enc{\PR_j} \parop \handler) \quad  \text{ and }\\
\PP_1
& \equiv & \rest{\tilde{\NK}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \prod\limits_{j\in J}\rep\PR_j )
\end{array}
\]
where $\handler=\prod\limits_{\NK\in\tilde{\NK}}\handler_\NK$, 
and if $\enc{\PP_1}=\context[\enc{\pi.\PQ}]$ then there is some $i\in I$ such that $\pi.\PQ=\pi_i.\PP_i$. Therefore, 
\[
\begin{array}{@{}c@{}c@{}l@{}}
\hspace{-2.5mm} \enc{\PP} 
& \equiv & \rep\rest{\tilde{\NK},\tilde{\NM}_\NK}(\prod\limits_{i\in I} \enc{\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep\enc{\PR_j} \parop \handler) \\
& \equiv & \rest{\tilde{\NK},\tilde{\NM}_\NK}(\prod\limits_{i\in I} \enc{\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep\enc{\PR_j} \parop \handler)
\parop \rep\rest{\tilde{\NK}',\tilde{\NM}_\NK'}(\prod\limits_{i\in I} \enc{\pi_i'.\PP_i'} \parop \prod\limits_{j\in J} \rep\enc{\PR_j'} \parop \handler')\\
& \equiv & 
\rest{\tilde{\NK},\tilde{\NM}_\NK}(\prod\limits_{i\in I} \enc{\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep\enc{\PR_j} \parop \rep\enc{\PQ} \parop \handler)\quad \text{ and }\\ 
\end{array} 
\]
\[
\begin{array}{@{}c@{}c@{}l@{}}
\PP 
& \equiv & \rep\rest{\tilde{\NK}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \prod\limits_{j\in J} \rep\PR_j ) \\
& \equiv & \rest{\tilde{\NK}}(\prod\limits_{i\in I} {\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep{\PR_j})
\parop \rep\rest{\tilde{\NK}'}(\prod\limits_{i\in I} {\pi_i'.\PP_i'} \parop \prod\limits_{j\in J} \rep{\PR_j'} )\\
& \equiv & 
\rest{\tilde{\NK}}(\prod\limits_{i\in I} {\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep{\PR_j} \parop \rep{\PQ} \parop \handler)
\end{array} 
\]
where, in both cases we use $\alpha$-conversion to distinguish between bound names of the replicated process and the activated copy, and hence, 
$\PQ= \rest{\tilde{\NK}'}(\prod\limits_{i\in I} {\pi_i'.\PP_i'} \parop \prod\limits_{j\in J} \rep{\PR_j'} )\equiv_\alpha\rest{\tilde{\NK}}(\prod\limits_{i\in I} {\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep{\PR_j})$. 
%$\rest{\tilde{\NN},\tilde{\NM}_\NN}(\prod\limits_{i\in I} \rho_i.\enc{\PP_i} \parop \enc{\PR} \parop \handler)=\rest{\tilde{\NN}',\tilde{\NM}_\NN'}(\prod\limits_{i\in I} \rho_i'.\enc{\PP_i'} \parop \enc{\PR'} \parop \handler')$ via $\alpha$-conversion, and where $\rho_i'.\enc{\PP_i'}=\enc{\pi'.\PP_i'}$. 
Since the active prefixes of $\enc{\PP}$ are also active prefixes of $\enc{\PP'}$ we may conclude the proof.
\end{enumerate}
\end{proof}

%\begin{lemma}\label{lem:shape_of_pi_processes}
%Let $\PP$ be a $\pi$-calculus process. Then there are $\tilde{\NN},\pi_i,\PP_i$ and $\PR$ such that 
%\[
%\PP\equiv \rest{\tilde{\NN}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \PR),
%\]
%where if $\PP= \context[\pi_j.\PP_j]$ then $j\in I$ and where rule \rulename{(sc-res-inact)} is not used.
%\end{lemma}
%\begin{proof}
%By induction on the structure of process $\PP$.
%\begin{itemize}
%\item  If $\PP=\pi.\PP'$ the proof follows directly.
%\item  Case $\PP=\PP_1 \parop \PP_2$. By induction hypothesis  
%$\PP_1\equiv \rest{\tilde{\NN}_1}(\prod\limits_{i\in I_1} \pi_i.\PP_i \parop \PR_1)$, where if $\PP_1= \context[\pi_j.\PP_j]$ then $j\in I_1$, and $\PP_2\equiv \rest{\tilde{\NN}_2}(\prod\limits_{i\in I_2} \pi_i.\PP_i \parop \PR_2)$, where if $\PP_2= \context[\pi_j.\PP_j]$ then $j\in I_2$. Hence,
%\[
%\begin{array}{@{}c@{}c@{}l@{}}
%\PP 
%& \equiv & \rest{\tilde{\NN}_1}(\prod\limits_{i\in I_1} \pi_i.\PP_i \parop \PR_1) \parop \rest{\tilde{\NN}_2}(\prod\limits_{i\in I_2} \pi_i.\PP_i \parop \PR_2)\\
%& \equiv & \rest{\tilde{\NN}_1, \tilde{\NN}_2}(\prod\limits_{i\in I_1\cup I_2} \pi_i.\PP_i \parop (\PR_1 \parop\PR_2))
%\end{array}
%\]
%since without loss of generality we can assume $\tilde{\NN}_1\cap \fn{\PP_2}=\emptyset$ and $\tilde{\NN}_2\cap \fn{\PP_1}=\emptyset$. Since the active prefixes of $\PP$ are the ones of the $\PP_1$ and $\PP_2$, we may conclude the case.
%\item Case $\PP=\rest\NK\PP_1$. By induction hypothesis we have 
%$\PP_1\equiv \rest{\tilde{\NN}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \PR)$, where if $\PP_1= \context[\pi_j.\PP_j]$ then $j\in I$. Since $\equiv$ is a congruence, we have 
%\[
%\PP  \equiv  \rest\NK\rest{\tilde{\NN}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \PR).
%\]
%\item Case $\PP=\rep\PP_1$. Again, by induction hypothesis we have 
%$\PP_1\equiv \rest{\tilde{\NN}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \PR)$, where if $\PP_1= \context[\pi_j.\PP_j]$ then $j\in I$. Therefore, 
%\[
%\begin{array}{@{}c@{}c@{}l@{}}
%\PP 
%& \equiv & \rep\rest{\tilde{\NN}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \PR) \\
%& \equiv & \rest{\tilde{\NN}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \PR) \parop \rep\rest{\tilde{\NN}'}(\prod\limits_{i\in I} \pi_i'.\PP_i' \parop \PR')\\
%& \equiv & \rest{\tilde{\NN}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop (\PR \parop \rep\rest{\tilde{\NN}'}(\prod\limits_{i\in I} \pi_i'.\PP_i' \parop \PR')),
%\end{array}
%\]
%where $\rest{\tilde{\NN}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \PR)=\rest{\tilde{\NN}'}(\prod\limits_{i\in I} \pi_i'.\PP_i' \parop \PR')$ via $\alpha$-conversion. Since active prefixes of $\PP$ are also active prefixes of $\PP_1$ we may conclude the proof.
%\end{itemize}
%\end{proof}

%We can use the last lemma to single out the two prefixes of a process that are to be engaged in the reduction.

%\begin{lemma}
%If $\PP$ is a $\pi$ process and $\PP\red\PQ$ then
%\[
%\PP\equiv \rest{\tilde{\NN}}(\send\NA\role\msg\NB.\PP_1 \parop \receive\NA\role\msg\NX.\PP_2 \parop \PR) \text{ and }
%\PQ\equiv \rest{\tilde{\NN}}(\PP_1 \parop \PP_2\subst{\NB}{\NX} \parop \PR).
%\]
%\end{lemma}
%\begin{proof}
%By induction on $\red$ we can show that if $\PP\red\PQ$ then


%\new{HERE!!!!!}
 
%\[\PP=\context[\context'[\send\NA\role\msg\NB.\PP_1] \parop \context''[\receive\NA\role\msg\NX.\PP_2]] \text{ and } \PQ=\context[\context'[\PP_1] \parop \context''[\PP_2\subst{\NB}{\NX}]],
%\] for some contexts $\context[\cdot], \context'[\cdot], \context''[\cdot]$, and processes $\send\NA\role\msg\NB.\PP_1$ and  $\receive\NA\role\msg\NX.\PP_2$.

%\end{proof}

%The only structural congruence rule dealing with the channel restrictions applied to $\pi$ processes in the last lemma is \rulename{(sc-res-extr)}, and only for ``pulling out'' the channel restrictions. Hence, indeed rule \rulename{(sc-res-inact)} is not used. 

%Combining the definition of the encoding, Lemma~\ref{{lem:shape_of_pi_processes}} and Corollary~\ref{cor:encode-struct-to-struct} we may also single out active prefixes of the encoded processes.





%Our next result shows that if the two target terms are structural equivalent, then so are their sources.  Notice first that not all the structural congruence rules can be applied in isolation in the encoded term so as to result in another encoded term. For instance, rule \rulename{(sc-res-inact)} is not applicable at all. In one direction in any encoded process channel restrictions are always mentioned in the scoped process (in the handler processes, and maybe also in the encoding of output prefixes) hence cannot be discarded immediately.  In the other direction, introducing channel restriction with a fresh name results in a process that is not encoding of any $\pi$-calculus process.
%
%\begin{lemma}\label{lem:struc_of_enc_struc_of_the_original}
%If $\enc{\PP}\equiv\enc{\PQ}$ then $\PP\equiv\PQ$.
%\end{lemma}
%
%\begin{proof}
%The proof is by case analysis of the rule applied.  We have the following cases for the proof.
%\begin{itemize}
%\item Rule \rulename{(sc-par-inact)}, \rulename{(sc-par-comm)} or \rulename{(sc-par-assoc)}. We detail only \rulename{(sc-par-comm)} as all three cases are similar. 
%Assume $\enc{\PP}=\PQ_1 \parop \PQ_2 \equiv \PQ_2 \parop \PQ_1= \enc{\PQ}$. By definition of the encoding we may conclude that there exist $\PP_1$ and $\PP_2$ such that $\PP=\PP_1 \parop \PP_2$, and hence $\enc{\PP_1}=\PQ_1$ and $\enc{\PP_2}=\PQ_2$. Therefore,  $\enc{\PQ}=\enc{\PP_2\parop\PP_1}$ and we conclude $\PP\equiv \PQ$ by \rulename{(sc-par-comm)}.
%
%\item Rule \rulename{(sc-mat)} or \rulename{(sc-rep)} follow the similar lines.
%\item Scope extrusion and scope swapping are similar, and we will detail only the former. Scope extrusion in a target process is only applicable for restrictions introduced by the encoding of channel restrictions, as extruding the scope of channel restrictions introduced by the encoding of output prefix would end up in a process that is not a target term of any $\pi$-calculus process. Hence, the only case where a form of scope extrusion on target terms is applicable if 
%\[
%\enc{\PP}=\enc{\PP_1} \parop \rest{\NK, \NM_\NK}(\enc{\PP_2} \parop \handler_\NK)\equiv \rest{\NK, \NM_\NK}((\enc{\PP_1} \parop \enc{\PP_2}) \parop \handler_\NK)=\enc{\PQ},
%\]
%where $\NK,\NM_\NK\not\in\fn{\enc{\PP_1}}$. Now we only need to notice that $\PP=\PP_1\parop \rest\NK\PP_2$ and $\PQ=\rest\NK(\PP_1 \parop \PP_2)$, and that $\NK\not\in\fn{\PP_1}$ follows from $\NK,\NM_\NK\not\in\fn{\enc{\PP_1}}$ and the definition of the renaming policy.
%\end{itemize}
%\end{proof}



The reduction steps of the target terms can be divided into four kinds. 
In order to refer to each of a kind in the following results, we will explicitly decorate the reduction arrows.
The first kind is the first reduction of the target term itself. 
As we already noted, the first reduction of a target term, which we denote with $\red_1$, is always carried out on a channel that is also free in the source term. This is a consequence of the definition of the encoding that the subject of active prefixes of the source terms are preserved, while the active prefixes of the handlers are all inputs with subject names introduced by the renaming policy (i.e., different from all source names). 
The steps after the first reduction are then uniquely determined. The sending process must synchronize with the corresponding handler (kind two, denoted with $\red_2$), as the translating function introduces receiving prefixes on the channels which names are introduced by the renaming policy only in the handler processes.  
Then, the receiving and the handler process synchronize on a private channel (kind three, $\red_3$), which name is from the reserved set of names, and afterwards, the sending and the receiving process directly synchronize (kind four, $\red_4$) also on a private channel, hence activating a process that is a target term (up to structural congruence).
Thus, we have
\[
\begin{array}{@{}l@{}c@{}l}
 \enc{\match{\tilde{\NA}}\role\msg{\tilde{\NA}}\send\NGG\role\msg\NL.\PP \parop \match{\tilde{\NB}}\role\msg{\tilde{\NB}}\receive\NGG\role\msg\NX.\PQ} \parop \handler_\NL
 & \equiv &  
 \rest{\NE_1,\NE_2}( \send{\NGG}\role\msg{(\NE_1,\NE_2)}.\send{\NM_\NL}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP }\\
 & \parop & \receive\NGG\role\msg{(\NY,\NZ)}.\receive\NY\role\msg{(\NX,\NM_\NX)}.\receive{\NZ}\role\msg{\NZ'}. \enc{\PQ} ) \parop  \handler_\NL\\
 &\red_1  & \\
 &  & \rest{\NE_1,\NE_2}( \send{\NM_\NL}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP }\\
 & \parop & \receive{\NE_1}\role\msg{(\NX,\NM_\NX)}.\receive{\NE_2}\role\msg{\NZ'}. \enc{\PQ}) \parop \handler_\NL\\
  &\red_2  & \\
 & & \rest{\NE_1,\NE_2}( \send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP }\\
 & \parop & \receive{\NE_1}\role\msg{(\NX,\NM_\NX)}.\receive{\NE_2}\role\msg{\NZ'}. \enc{\PQ}  \parop  \send{\NE_1}\role\msg{(\NL,\NM_\NL)}) \parop \handler_\NL\\
  &\red_3  & \\
 & & \rest{\NE_1,\NE_2}( \send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP }\\
 & \parop & \receive{\NE_2}\role\msg{\NZ'}. \enc{\PQ\subst{\NL}{\NX}} ) \parop \handler_\NL\\
   &\red_4  & \\
 & &   \enc{ \PP  \parop \PQ\subst{\NL}{\NX}}  \parop \handler_\NL\\
\end{array}
\]
Notice that the type of reduction is invariant with respect to the application of reduction rules \rulename{(r-par)}, \rulename{(r-res)} and \rulename{(r-stru)}.
We also denote the intermediate sub-processes derived in these reductions with %after the initial synchronization on $\NK$
\[
\begin{array}{@{}l@{\;}c@{\;}l}
%\Proc_0^\NL(\PP,\PQ) & = & \rest{\NE_1,\NE_2} (\send{\NK}\role\msg{(\NE_1,\NE_2)}.\send{\NM_\NL}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP } \parop  \receive\NK\role\msg{(\NY,\NZ)}.\receive\NY\role\msg{(\NX,\NM_\NX)}.\receive{\NZ}\role\msg{\NZ'}. \enc{\PQ})\\
\Proc_1^\NL(\PP,\PQ) & = &  \rest{\NE_1,\NE_2}( \send{\NM_\NL}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP } \parop \receive{\NE_1}\role\msg{(\NX,\NM_\NX)}.\receive{\NE_2}\role\msg{\NZ'}. \enc{\PQ})\\
\Proc_2^\NL(\PP,\PQ) & = & \rest{\NE_1,\NE_2}( \send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP }
  \parop  \receive{\NE_1}\role\msg{(\NX,\NM_\NX)}.\receive{\NE_2}\role\msg{\NZ'}. \enc{\PQ}  \parop  \send{\NE_1}\role\msg{(\NL,\NM_\NL)})\\
  \Proc_3^\NL(\PP, \PQ) & = & \rest{\NE_1,\NE_2}( \send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP }
  \parop  \receive{\NE_2}\role\msg{\NZ'}. \enc{\PQ\subst{\NL}{\NX}} )
\end{array}
\]

We may present now our first result characterizing the structure of the reducing target term and its correlation with the corresponding source term.


\begin{lemma}[A first reduction of a target term]\label{lem:first_reduction_of_encoded_processes}
Let $\PP$ be a $\pi$ process and $\PQ$ a $C_\pi$ process such that $\enc{\PP}\red\PQ$. Then 
\[
\begin{array}{@{}c@{}c@{}l@{}}
\enc{\PP} & \equiv & \rest{\tilde{\NK}, \tilde{\NM}_\NK}(\enc{\send\NGG\role\msg\NL.\PP_1\parop \receive\NGG\role\msg\NX.\PQ_1} \parop \enc{\PR} \parop \handler)\\
\PQ & \equiv & \rest{\tilde{\NK}, \tilde{\NM}_\NK}(\Proc_1^\NL(\PP_1,\PQ_1) \parop \enc{\PR} \parop \handler)  \text{ and }\\
\PP & \equiv & \rest{\tilde{\NK}}(\send\NGG\role\msg\NL.\PP_1\parop \receive\NGG\role\msg\NX.\PQ_1 \parop \PR) \\
\end{array}
 \]
where $\handler=\prod\limits_{\NK\in\tilde{\NK}}\handler_\NK$.
\end{lemma}
\begin{proof}
Assume $\enc{\PP}\red\PQ$. 
%By the definition of the encoding, the only active prefixes of the encoded process have the same barbs as the ones in the source process, except the active input barbs in the handler processes. 
%Since only the active prefixes in the handlers, which are all inputs, have as a subject name introduced by the renaming policy, we conclude that in the encoded process these inputs lack the corresponding output prefixes in order to be engaged in a reduction.
By Lemma~\ref{lem:shape_of_encoded_processes} we can single out all active prefixes, hence
\[
\begin{array}{c@{\,}c@{\,}l}
\enc{\PP}
& \equiv & \rest{\tilde{\NK},\tilde{\NM}_\NK}(\prod\limits_{i\in I} \enc{\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep\enc{\PR_j} \parop \handler) \quad  \text{ and }\\
\PP 
& \equiv & \rest{\tilde{\NK}}(\prod\limits_{i\in I} \pi_i.\PP_i \parop \prod\limits_{j\in J}\rep\PR_j )
\end{array}
\]
where $\handler=\prod\limits_{\NK\in\tilde{\NK}}\handler_\NK$, 
and if $\enc{\PP}=\context[\enc{\pi.\PQ}]$ then there exist $i\in I$ such that $\pi.\PQ=\pi_i.\PP_i$. 
We can now single out the two prefixes that are involved in the reduction. Therefore,
\[
\begin{array}{c@{\,}c@{\,}l}
\enc{\PP}
& \equiv & \rest{\tilde{\NK},\tilde{\NM}_\NK}(\enc{\send\NGG\role\msg\NL.\PP_j} \parop \enc{\receive\NGG\role\msg\NX.\PP_s} \parop \prod\limits_{i\in I\setminus\{j,s\}} \enc{\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep\enc{\PR_j} \parop \handler) \quad \text{ and }\\
\PP
& \equiv & \rest{\tilde{\NK}}({\send\NGG\role\msg\NL.\PP_j} \parop {\receive\NGG\role\msg\NX.\PP_s} \parop \prod\limits_{i\in I\setminus\{j,s\}} {\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep{\PR_j} )
\end{array}
\]
If we denote $\PR=\prod\limits_{i\in I\setminus\{j,s\}} {\pi_i.\PP_i} \parop \prod\limits_{j\in J} \rep{\PR_j}$, we have that
\[
\begin{array}{c@{\,}c@{\,}l}
\enc{\PP}
& \equiv & \rest{\tilde{\NK},\tilde{\NM}_\NK}(\enc{\send\NGG\role\msg\NL.\PP_j \parop \receive\NGG\role\msg\NX.\PP_s} \parop \enc{\PR} \parop \handler) \quad \text{ and }\\
\PP
& \equiv & \rest{\tilde{\NK}}({\send\NGG\role\msg\NL.\PP_j} \parop {\receive\NGG\role\msg\NX.\PP_s} \parop \PR )
\end{array}
\]
Since $\rest{\tilde{\NK},\tilde{\NM}_\NK}(\enc{\send\NGG\role\msg\NL.\PP_j \parop \receive\NGG\role\msg\NX.\PP_s} \parop \enc{\PR}  \parop \handler) \red \rest{\tilde{\NK},\tilde{\NM}_\NK}(\Proc_1^\NL(\PP_j, \PP_s) \parop \enc{\PR}  \parop \handler)$, and $\enc{\PP}\red\PQ$, we conclude 
\[
\PQ\equiv \rest{\tilde{\NK},\tilde{\NM}_\NK}(\Proc_1^\NL(\PP_j, \PP_s) \parop \enc{\PR}  \parop \handler)
\]
%Since $\enc{\PP}\equiv \rest{\tilde{\NN},\tilde{\NM}_\NN}(\rho_j.\enc{\PP_j} \parop \rho_s.\enc{\PP_s} \parop \enc{\PR}  \parop \handler)$, by Lemma~\ref{lem:struc_of_enc_struc_of_the_original} we conclude $\PP\equiv \rest{\tilde{\NN}}(\send\NK\role\msg\NL.\PP_j \parop \receive\NK\role\msg\NX.\PP_s \parop \PR)$.
\end{proof}

%\begin{proof}
%By the induction on the last reduction rule applied. 

%Hence, the base case we get if 
%\[\enc{\PP}=\rest{\NE_1,\NE_2} \match{\tilde{\NA}}\role\msg{\tilde{\NA}}\send{\NK}\role\msg{(\NE_1,\NE_2)}.\send{\NM_\NL}\role\msg{\NE_1}.\send{\NE_2}\role\msg{\NE_1}.  \enc{ \PP_1 }
% \,|\,  \match{\tilde{\NB}}\role\msg{\tilde{\NB}}\receive\NK\role\msg{(\NY,\NZ)}.\receive\NY\role\msg{(\NX,\NM_\NX)}.\receive{\NZ}\role\msg{\NZ'}. \enc{\PQ_1}
% \]
%Then, $\enc{\PP}\equiv\Proc_0^\NL(\PP_1,\PQ_1)\red \Proc_1^\NL(\PP_1,\PQ_1)=\PQ.$

%\emph{---Case \rulename{(r-res)}}.
%In this case we have $\enc{\PP}=\rest\NK\PQ'$ and $\rest\NK\PQ'\red \rest\NK\PQ''$ is derived from $\PQ'\red\PQ''$. Since $\enc{\PP}=\rest\NK\PQ'$, by the definition of the encoding we have  $\PQ'= \rest{\NM_\NK} (\enc{\PP''} \parop \handler_\NK)$, for some $\pi$ process $\PP''$. 
%Hence, by the discussion at the beginning of the proof we may conclude that $\rest{\NM_\NK} (\enc{\PP''} \parop \handler_\NK)\red \PQ''$ is derived by application of rules \rulename{(r-par)} and \rulename{(r-res)}, from 

%Assume $\enc{\PP}\red\PQ$ is derived from $\PP'\red\PQ'$, where $\enc{\PP}\equiv\PP'$ and $\PQ\equiv\PQ'$.
%\end{proof}








%\new{ Da li ovo treba?
%We may notice in the last proof that strong barbed equivalence is actually used only for the rule \rulename{(sc-res-inact)}. Hence, we also have the following result.
%
%\begin{corollary}\label{cor:encode-struct-to-struct}
%If $\PP\equiv\PQ$ is derived without using the rule \rulename{(sc-res-inact)} then $\enc\PP\equiv\enc\PQ$.
%\end{corollary}
%}

Notice that in the previous lemma the reduction is of type $1$.
Using Lemma~\ref{lem:first_reduction_of_encoded_processes} we may characterize all possible evolutions of the target terms after any number of reduction steps. For the rest of this section with $\PP\red^n\PQ$ we denote that process $\PP$ reduces to $\PQ$ in $n$ reduction steps, i.e., that $\PP\red\PP_1\red\ldots\red\PP_{n-1}\red\PQ$. If $\PP\red^n\PQ$ we denote by $n_i$ the number of reduction steps of kind $i$, for $i=1,2,3,4$, and hence we have that $n=n_1+n_2+n_3+n_4$.

%A direct consequence of Lemma~\ref{lem:first_reduction_of_encoded_processes} and the text preceding it is that after a first reduction of the target term (of kind $1$), the reductions of kind $2,3$ and $4$ are then determined, since process $\Proc_1^\NL(\PP_1,\PQ_1)$ reduces in isolation, only involving one copy of the corresponding handler process $\handler_\NL$. Furthermore, the same lemma implies that after the all four reductions of the target term the resulting process can be directly related to the reduced source term. Hence, we have the next result.
%
%\begin{corollary}\label{cor:four_reductions_of_the_target_term}
%Let $\PP$ be a $\pi$ process and $\PQ$ a $C_\pi$ process. If 
%\[
%\enc{\PP}\parop \handler\red_1\red_2\red_3\red_4\PQ\parop\handler
%\]
% where $\handler=\prod\limits_{\NK\in\fo\PP}\handler_\NK$, then there is a $\pi$ process $\PP'$ such that $\PP\red\PP'$ and $\enc{\PP'}\equiv\PQ$.
%\end{corollary}
%
%Our next auxiliary result shows that we can reason on the shape of target term after $n$ reductions using the structural congruence relation.



\begin{lemma}[An $n$-th reduction of the target term]\label{lem:for_soundness}
Let $\PP$ be a $\pi$ process and $\PQ$ a $C_\pi$ process, such that $\enc\PP \parop \handler \red^n \PQ$, where %$n=\sum\limits_{i=1}^4n_i$ and 
$\handler=\prod\limits_{\NK\in\fo\PP} \handler_{\NK}$. %, where $\handler=\inact$ if $\fn\PP=\emptyset$. 
Then 
\[
\PQ\equiv \rest{\tilde{\NK},\tilde{\NM}_\NK}\big( \enc{\PR} \parop \prod\limits_{i\in I_1} \Proc_1^{\NL_i}(\PP_i, \PQ_i) \parop \prod_{j\in I_2} \Proc_2^{\NL_j}(\PP_j, \PQ_j) \parop \prod_{s\in I_3} \Proc_3^{\NL_s}(\PP_s, \PQ_s) \parop \handler_1\big)\parop \handler
\]
where $I_1, I_2$ and $I_3$ are pair-wise disjoint sets, $\handler_1\equiv \prod\limits_{\NK\in\tilde{\NK}} \handler_\NK$, and $|I_t|=n_t-n_{t+1}$, for $t=1,2,3$, and there exist $\PP'$ such that $\PP\red^{n_4}\PP'$ and 
\[
\PP' \equiv \rest{\tilde{\NK}}\big(\PR \parop \prod\limits_{i \in I} (\send{\NGG_i}\role\msg{\NL_i}.\PP_i  \parop \receive{\NGG_i}\role\msg\NX.\PQ_i)\big)
\]
where $I=I_1\cup I_2\cup I_3$, and where $\PP'=\PP$ for $n_4=0$.
\end{lemma}
%
\begin{proof}
The proof is by induction on $n$. The base case follows directly from Lemma~\ref{lem:first_reduction_of_encoded_processes}. Assume now $\enc\PP \parop \handler \red^n \PQ\red \PQ'$. By induction hypothesis
\[
\PQ\equiv \rest{\tilde{\NK},\tilde{\NM}_\NK}\big( \enc{\PR} \parop \prod\limits_{i\in I_1} \Proc_1^{\NL_i}(\PP_i, \PQ_i) \parop \prod_{j\in I_2} \Proc_2^{\NL_j}(\PP_j, \PQ_j) \parop \prod_{s\in I_3} \Proc_3^{\NL_s}(\PP_s, \PQ_s) \parop \handler_1\big)\parop \handler
\]
where $I_1, I_2$ and $I_3$ are pair-wise disjoint, $\handler_1\equiv \prod\limits_{\NK\in\tilde{\NK}} \handler_\NK$ and $|I_t|=n_t-n_{t+1}$, for $t=1,2,3$, and there exist $\PP'$ such that $\PP\red^{n_4}\PP'$ and 
\[
\PP' \equiv \rest{\tilde{\NK}}\big(\PR \parop \prod\limits_{i \in I} (\send{\NGG_i}\role\msg{\NL_i}.\PP_i  \parop \receive{\NGG_i}\role\msg\NX.\PQ_i)\big)
\]
where $I=I_1\cup I_2\cup I_3$, and where $\PP'=\PP$ for $n_4=0$.
We now have only four cases for the kind of the reduction $\PQ\red\PQ'$.
\begin{enumerate}
\item Kind $1$. The reduction originates from $\enc\PR\red\PQ''$. By Lemma~\ref{lem:first_reduction_of_encoded_processes} we have that
\[
\begin{array}{@{}c@{}c@{}l@{}}
\enc{\PR} & \equiv & \rest{\tilde{\NK}', \tilde{\NM}_{\NK'}}(\enc{\PR'} \parop \enc{\send\NGG\role\msg\NL.\PP_1\parop \receive\NGG\role\msg\NX.\PQ_1} \parop  \handler')\\
\PQ'' & \equiv & \rest{\tilde{\NK}', \tilde{\NM}_{\NK'}}(\enc{\PR'} \parop \Proc_1^\NL(\PP_1,\PQ_1) \parop  \handler')  \text{ and }\\
\PR & \equiv & \rest{\tilde{\NK}'}(\PR' \parop \send\NGG\role\msg\NL.\PP_1\parop \receive\NGG\role\msg\NX.\PQ_1 ) \\
\end{array}
 \]
where $\handler=\prod\limits_{\NK\in\tilde{\NK}'}\handler_\NK$. 
The proof for this case follows by noting that processes $\PQ'$ and $\PP'$ have the expected forms, up to structural congruence. % we can rearrange the  process  as  %by   , restrictions $\rest{\tilde{\NK'}, \tilde{\NM}_\NK'}$ can be extruded and added to $\rest{\tilde{\NK},\tilde{\NM_\NK}}$ while their corresponding handlers $\handler'$ can be added to $\handler_1$.
%
\item Kind $2$. The reduction of $\PQ$ originates from $\Proc_1^{\NL_i}(\PP_i, \PQ_i)$ and one copy of the corresponding handler (either from $\handler_1$ or $\handler$), and their parallel composition evolves to process $\Proc_2^{\NL_i}(\PP_i, \PQ_i)$. Process $\PP'$ remains unchanged.
%
\item Kind $3$. The reduction of $\PQ$ originates from $\Proc_2^{\NL_i}(\PP_i, \PQ_i)$, that evolves to process $\Proc_3^{\NL_i}(\PP_i, \PQ_i)$ (using Corollary~\ref{lem:encode-subst}). Again, process $\PP'$ remains unchanged.
%
\item Kind $4$. Process $\Proc_3^{\NL_i}(\PP_i, \PQ_i)$ (in $\PQ$) evolves to $\enc{\PP_i \parop \PQ_i\subst{\NL_i}{\NX}}$, and the respective $\send\NGG\role\msg\NL.\PP_i\parop \receive\NGG\role\msg\NX.\PQ_i$ (in $\PP'$) evolves to $\PP_i\parop \PQ_i\subst{\NL_i}{\NX}$, which completes the proof.
\end{enumerate}
\end{proof}

%\new{BELLOW IS THE OLD RESULT!!!!!!}
%\begin{lemma}[Shape of target terms after $n$ reductions]\label{lem:for_soundness}
%Let $\PP$ be a $\pi$-calculus process and $\PQ$ a $C_\pi$ process, such that $\enc\PP \parop \handler \red^n \PQ$, where %$n=\sum\limits_{i=1}^4n_i$ and 
%$\handler=\prod\limits_{\NK\in\fo\PP} \handler_{\NK}$. %, where $\handler=\inact$ if $\fn\PP=\emptyset$. 
%Then 
%\[
%\PQ\equiv \rest{\tilde{\NK},\tilde{\NM}_\NK}\big( \enc{\PR} \parop \prod_{i=1}^{\overline{n}_1} \Proc_1^{\NL_i}(\PP_1^i, \PQ_1^i) \parop \prod_{j=1}^{\overline{n}_2} \Proc_2^{\NL_j}(\PP_2^j, \PQ_2^j) \parop \prod_{s=1}^{\overline{n}_3} \Proc_3^{\NL_s}(\PP_3^s, \PQ_3^s) \parop \handler_1\big)\parop \handler
%\]
%where $\handler_1\equiv \prod\limits_{\NK\in\tilde{\NK}} \handler_\NK$ and $\overline{n}_i=n_i-n_{i+1}$, for $i=1,2,3$.
%\end{lemma}
%
%\begin{proof}
%The proof is by induction on $n$. The base case follows directly from Lemma~\ref{lem:first_reduction_of_encoded_processes}. Assume now $\enc\PP \parop \handler \red^n \PQ\red \PQ'$. By induction hypothesis
%\[
%\PQ\equiv \rest{\tilde{\NK},\tilde{\NM_\NK}}\big( \enc{\PR} \parop \prod_{i=1}^{\overline{n}_1} \Proc_1^{\NL_i}(\PP_1^i, \PQ_1^i) \parop \prod_{j=1}^{\overline{n}_2} \Proc_2^{\NL_j}(\PP_2^j, \PQ_2^j) \parop \prod_{s=1}^{\overline{n}_3} \Proc_3^{\NL_s}(\PP_3^s, \PQ_3^s) \parop \handler_1\big)\parop \handler
%\]
%We now have only four cases for the kind of the reduction $\PQ\red\PQ'$.
%\begin{enumerate}
%\item Kind $1$. The reduction originates from $\enc\PR\red\PQ''$. By Lemma~\ref{lem:first_reduction_of_encoded_processes} we have that
%\[
%\begin{array}{@{}c@{}c@{}l@{}}
%\enc{\PR} & \equiv & \rest{\tilde{\NK}', \tilde{\NM}_{\NK'}}(\enc{\send\NK\role\msg\NL.\PP_1\parop \receive\NK\role\msg\NX.\PQ_1} \parop \enc{\PR'} \parop \handler')\\
%\PQ'' & \equiv & \rest{\tilde{\NK}', \tilde{\NM}_{\NK'}}(\Proc_1^\NL(\PP_1,\PQ_1) \parop \enc{\PR'} \parop \handler')  \text{ and }\\
%\PR & \equiv & \rest{\tilde{\NK}'}(\send\NK\role\msg\NL.\PP_1\parop \receive\NK\role\msg\NX.\PQ_1 \parop \PR') \\
%\end{array}
% \]
%where $\handler=\prod\limits_{\NM\in\tilde{\NK}'}\handler_\NM$. 
%The proof for this case follows by noting that process $\PQ'$ has the expected form, up to structural congruence. % we can rearrange the  process  as  %by   , restrictions $\rest{\tilde{\NK'}, \tilde{\NM}_\NK'}$ can be extruded and added to $\rest{\tilde{\NK},\tilde{\NM_\NK}}$ while their corresponding handlers $\handler'$ can be added to $\handler_1$.
%
%\item Kind $2$. The reduction originates from $\Proc_1^{\NL_i}(\PP_i, \PQ_i)$ and one copy of the corresponding handler (either from $\handler_1$ or $\handler$), and their parallel composition evolves to process $\Proc_2^{\NL_i}(\PP_i, \PQ_i)$, and the case follows.
%
%\item Kind $3$. The reduction originates from $\Proc_2^{\NL_i}(\PP_i, \PQ_i)$, that evolves to process $\Proc_3^{\NL_i}(\PP_i, \PQ_i)$ (using Corollary~\ref{lem:encode-subst}), and we may conclude the case.
%
%\item Kind $4$. Process $\Proc_3^{\NL_i}(\PP_i, \PQ_i)$ evolves to $\enc{\PP_i \parop \PQ_i\subst{\NL_i}{\NX}}$, which completes the proof.
%\end{enumerate}
%\end{proof}
%
%What we can also notice is that if $\enc{\PP}\parop \handler\red^n\PQ\parop \handler$ where some  reductions of kind $1$ \new{HERE!!!!}
%
%\begin{corollary}
%Let $\PP$ be a $\pi$ process and $\PQ$ a $C_\pi$ process such that $\enc{\PP}\parop\handler\red^n\PQ\parop\handler$, where $\handler=\prod\limits_{\NK\in\fo\PP}\handler_\NK$ and $n_1=n_2=n_3=n_4$. Then, there are $\PQ_1, \ldots, \PQ_{n_1-1}$ $C_\pi$ processes such that
%\[
%\enc{\PP} \parop \handler \red_1\red_2\red_3\red_4 \PQ_1\parop\handler\red_1\red_2\red_3\red_4 \ldots \PQ_{n_1-1}\parop \handler\red_1\red_2\red_3\red_4\PQ\parop\handler
%\]
%\end{corollary}

The above result shows that our encoding does not introduce any unexpected computations. That is, for each possible evolution of the target term there is a corresponding evolution of the source term. That is the essence of the soundness result we aim to prove.
Formally, our soundness result states that if a target term $\enc{\PP}$ reduces (in a number of steps) to some process $\PQ$ then the source term $\PP$ also reduces (in a number of steps) to a process $\PP'$, where $\PQ$ can reach $\enc{\PP'}$ by reducing to it (in a number of steps).  Similarly to the completeness result, we first show that the soundness of the encoding holds for any $\pi$ processes if the ``top-level'' handlers are used. 
 
 
 \begin{lemma}[Soundness with top-level handlers]\label{lem:soundness_with_handlers}
Let $\PP$ be a $\pi$-calculus process and $\PQ$ be a $C_\pi$ process such that $\enc\PP \parop \handler \red^n \PQ$, where $\handler=\prod\limits_{\NK\in\fo\PP} \handler_{\NK}$. %, where $\handler=\inact$ if $\fn\PP=\emptyset$. 
Then, there is a $\pi$-calculus process $\PP'$ such that $\PP\red^{n_1} \PP'$ and $\PQ\red^m \enc{\PP'} \parop \handler$, where $m=3n_1-n_2-n_3-n_4$. 
\end{lemma}

\begin{proof}
Assume $\enc\PP \parop \handler \red^n \PQ$. By Lemma~\ref{lem:for_soundness} we have that 
\[
\PQ\equiv \rest{\tilde{\NK},\tilde{\NM}_\NK}\big( \enc{\PR} \parop \prod\limits_{i\in I_1} \Proc_1^{\NL_i}(\PP_i, \PQ_i) \parop \prod_{j\in I_2} \Proc_2^{\NL_j}(\PP_j, \PQ_j) \parop \prod_{s\in I_3} \Proc_3^{\NL_s}(\PP_s, \PQ_s) \parop \handler_1\big)\parop \handler
\]
where $\handler_1\equiv \prod\limits_{\NK\in\tilde{\NK}} \handler_\NK$ and $|I_t|=n_t-n_{t+1}$, for $t=1,2,3$, and there exist a $\pi$ process $\PP''$ such that $\PP\red^{n_4}\PP''$ and 
\[
\PP'' \equiv \rest{\tilde{\NK}}\big(\PR \parop \prod\limits_{i \in I} (\send{\NGG_i}\role\msg{\NL_i}.\PP_i  \parop \receive{\NGG_i}\role\msg\NX.\PQ_i)\big)
\]
where $I=I_1\cup I_2\cup I_3$, and where $\PP''=\PP$ for $n_4=0$. Thus, by performing synchronizations of the processes in the product in the process structurally equivalent to $\PP''$ we can show that 
\[
\PP''\red^{s}\rest{\tilde{\NK}}\big(\PR \parop \prod\limits_{i \in I} (\PP_i  \parop \PQ_i\subst{\NL_i}{\NX})\big)
\]
%
where $s=n_1-n_4$. 
By performing reductions of kind $2,3$ and $4$ in the process structurally equivalent to $\PQ$ (three for each $i\in I_1$, two for each $j\in I_2$, and one for each $s\in I_3$) we have that
\[
\PQ\red^m \enc{\rest{\tilde{\NK}}\big(\PR \parop \prod\limits_{i \in I} (\PP_i  \parop \PQ_i\subst{\NL_i}{\NX})\big)}\parop \handler
\]
where $m=3n_1-n_2-n_3-n_4$. 
% \[
%\PQ\red^m\rest{\tilde{\NK},\tilde{\NM}_\NK}\big( \enc{\PR'} \parop \handler_1\big)\parop \handler
%\] where 
%\[
%\enc{\PR'}=\enc{\PR} \parop \prod_{i=1}^{\overline{n}_1} \enc{\PP_i\parop \PQ_i\subst{\NL_i}{\NX}} \parop \prod_{j=1}^{\overline{n}_2} \enc{\PP_j\parop \PQ_j\subst{\NL_j}{\NX}} \parop \prod_{s=1}^{\overline{n}_3} \enc{\PP_s\parop \PQ_s\subst{\NL_s}{\NX}}
%\]
\end{proof}
 
%\begin{lemma}[Soundness with top-level handlers]\label{lem:soundness_with_handlers}
%Let $\PP$ be a $\pi$-calculus process and $\PQ$ be a $C_\pi$ process such that $\enc\PP \parop \handler \red^n \PQ$, where $\handler=\prod\limits_{\NK\in\fo\PP} \handler_{\NK}$. %, where $\handler=\inact$ if $\fn\PP=\emptyset$. 
%Then, there is a $\pi$-calculus process $\PP'$ such that $\PP\red^{n_1} \PP'$ and $\PQ\red^m \enc{\PP'} \parop \handler$, where $m=3n_1-n_2-n_3-n_4$. 
%\end{lemma}
%
%\begin{proof}
%Assume $\enc\PP \parop \handler \red^n \PQ$. By Lemma~\ref{lem:for_soundness} we have that 
%\[
%\PQ\equiv \rest{\tilde{\NK},\tilde{\NM_\NK}}\big( \enc{\PR} \parop \prod_{i=1}^{\overline{n}_1} \Proc_1^{\NL_i}(\PP_1^i, \PQ_1^i) \parop \prod_{j=1}^{\overline{n}_2} \Proc_2^{\NL_j}(\PP_2^j, \PQ_2^j) \parop \prod_{s=1}^{\overline{n}_3} \Proc_3^{\NL_s}(\PP_3^s, \PQ_3^s) \parop \handler_1\big)\parop \handler
%\]
%where $\handler_1\equiv \prod\limits_{\NK\in\tilde{\NK}} \handler_\NK$ and $\overline{n}_i=n_i-n_{i+1}$, for $i=1,2,3$.
%By performing reductions of kind $2,3$ and $4$ we get 
%\[\PQ\red^*\rest{\tilde{\NK},\tilde{\NM}_\NK}\big( \enc{\PR'} \parop \handler_1\big)\parop \handler
%\]
%where 
%\[
%\enc{\PR'}=\enc{\PR} \parop \prod_{i=1}^{\overline{n}_1} \enc{\PP_i\parop \PQ_i\subst{\NL_i}{\NX}} \parop \prod_{j=1}^{\overline{n}_2} \enc{\PP_j\parop \PQ_j\subst{\NL_j}{\NX}} \parop \prod_{s=1}^{\overline{n}_3} \enc{\PP_s\parop \PQ_s\subst{\NL_s}{\NX}}
%\]
%
%\new{HERE!!!!}%
%
%To conclude the proof we apply Lemma~\ref{lem:first_reduction_of_encoded_processes} and notice that for each kind $1$ reduction of the target term $\enc{\PR}\red\PQ$ holds 
%\[
%\begin{array}{@{}c@{}c@{}l@{}}
%\enc{\PR} & \equiv & \rest{\tilde{\NN}, \tilde{\NM}_\NN}(\Proc_0^\NL(\PP_1, \PQ_1) \parop \enc{\PR'} \parop \handler'),\\
%\PQ & \equiv & \rest{\tilde{\NN}, \tilde{\NM}_\NN}(\Proc_1^\NL(\PP_1,\PQ_1) \parop \enc{\PR'} \parop \handler'),  \text{ and }\\
%\PR & \equiv & \rest{\tilde{\NN}}(\send\NK\role\msg\NL.\PP_1\parop \receive\NK\role\msg\NX.\PQ_1 \parop \PR), \\
%\end{array}
% \]
%where $\handler=\prod\limits_{\NN\in\tilde{\NN}}\handler_\NN$. 
%Hence, we may notice that the source term can also reduce $\PR\red\rest{\tilde{\NN}}(\PP_1\parop \PQ_1\subst{\NL}{\NX} \parop \PR')$ and that 
%\[
%\PQ\red_2\red_3\red_4 \rest{\tilde{\NN}, \tilde{\NM}_\NN}(\enc{\PP_1 \parop \PQ_1\subst{\NL}{\NX}} \parop \enc{\PR'} \parop \handler')= \enc{\rest{\tilde{\NN}}(\PP_1\parop \PQ_1\subst{\NL}{\NX} \parop \PR')}.
%\]
%
%We conclude by noting that $\PR''$ is the process derived from $\PP$ by performing $n_1$ reductions associated with $n_1$ reductions of the type $1$ in $\enc{\PP} \parop \handler\red^n\PQ$.
%\end{proof}


As a direct consequence of the last lemma, we get the operational soundness result for our encoding.

\begin{corollary}[Operational correspondence: soundness]\label{cor:op_corresp_soundness}
Let $\PP$ be a (sum-free) $\pi$-calculus process and $\PQ$ be a $C_\pi$ process, such that $\fo\PP=\emptyset$ and $\enc\PP \red^n \PQ$.
Then, there is a $\pi$-calculus process $\PP'$ such that $\PP\red^{n_1} \PP'$ and $\PQ\red^m \enc{\PP'}$, where $m=3n_1-n_2-n_3-n_4$. 
\end{corollary}

Using the observation that whenever $\enc{\PP}\red^n\PQ$ then $n_1\geq \frac{n}{4}$, and Lemma~\ref{lem:soundness_with_handlers} we can directly conclude that our encoding does not introduce divergence computations (cf.~\cite{DBLP:journals/iandc/Gorla10}).
 
\begin{corollary}[Divergence reflection]
Let $\PP$ be a $\pi$ process. 
If $\enc{\PP} \parop \handler\red^\omega$, where $\handler=\prod\limits_{\NK\in\fo\PP} \handler_{\NK}$, then $\PP\red^\omega$.
\end{corollary}
%\begin{proof}
%Let $\enc{\PP} \parop \handler\red^n$. By observing that the reduction of type $i$ can be conducted only if the corresponding reductions of type $j$, with $j<i$, have taken place, we can conclude $n_1\geq \frac{n}{4}$. Hence, if $n\to\infty$ then $ n_1\to\infty$, and we may conclude the proof by Lemma~\ref{lem:soundness_with_handlers}. 
%\end{proof}

\section{Remarks}\label{subsec:Cpi-remarks}

Notice that translating the $\pi$-calculus terms into the $C_\pi$-calculus via the encoding presented in Section~\ref{subsec:the_encoding} has one positive consequence to what concerns controlling channel sharing. The only processes which are able to send channels originally specified in the source $\pi$ process are handlers, i.e., handlers are the administrators in the target terms for the channels of the source terms. 
Now, if a channel from the source language is to be considered confidential, one has a fixed domain in which control needs to be established. This is in contrast to the regular $\pi$ processes where one cannot statically identify a domain where the channel sending capability is confined to. 
The mentioned control can be exploited also to bound the number of times channels are communicated, an exploration we leave for future work. We remark that such a notion of accounting is to some extent connected with the notion of accounting of usages of channels via floating authorizations presented in the next chapter.